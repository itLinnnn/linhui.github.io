<!DOCTYPE html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/linhui.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/linhui.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/linhui.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/linhui.github.io/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/linhui.github.io/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/linhui.github.io/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/linhui.github.io/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Hexo, NexT"><link rel="alternate" href="/linhui.github.io/atom.xml" title="林晖的个人博客" type="application/atom+xml"><meta name="description" content="正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。 概念： Regular Expression使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。说简单了就是按照某种规则去匹配符合条件的字符串。  RegExp对象 javaScript中通过内置对象 RegExp 支持正"><meta property="og:type" content="article"><meta property="og:title" content="正则表达式"><meta property="og:url" content="https://itlinnnn.github.io/linhui.github.io/正则表达式/index.html"><meta property="og:site_name" content="林晖的个人博客"><meta property="og:description" content="正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。 概念： Regular Expression使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。说简单了就是按照某种规则去匹配符合条件的字符串。  RegExp对象 javaScript中通过内置对象 RegExp 支持正"><meta property="og:locale" content="default"><meta property="og:updated_time" content="2018-09-16T04:06:13.237Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="正则表达式"><meta name="twitter:description" content="正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。 概念： Regular Expression使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。说简单了就是按照某种规则去匹配符合条件的字符串。  RegExp对象 javaScript中通过内置对象 RegExp 支持正"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/linhui.github.io/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://itlinnnn.github.io/linhui.github.io/正则表达式/"><title>正则表达式 | 林晖的个人博客</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="default"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/linhui.github.io/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">林晖的个人博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/linhui.github.io/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/linhui.github.io/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/正则表达式/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">正则表达式</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-15T00:00:00+08:00">2018-09-15</time></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。"><a href="#正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。" class="headerlink" title="正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。"></a>正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。</h4><blockquote><p>概念： Regular Expression使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。说简单了就是按照某种规则去匹配符合条件的字符串。</p></blockquote><h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><hr><p>javaScript中通过内置对象 RegExp 支持正则表达式，有两种方法实例化 RegExp 对象：</p><p>1.字面量<br>2.构造函数</p><h3 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h3><p>假设你需要把一句英文里面的小写is匹配成大写的 IS，可以这样做：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/is/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'He is a boy, This is a dog. Where is she?'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'IS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//He IS a boy, This is a dog. Where is she?</span></span><br></pre></td></tr></table></figure><p></p><p>这样就把第一个英文单词’is’替换成了’IS’，假如你想把该句中所有的单词’is’都替换成’IS’,应该这样写：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/is/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'He is a boy, This is a dog. Where is she?'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'IS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//He IS a boy, ThIS IS a dog. Where IS she?</span></span><br></pre></td></tr></table></figure><p></p><p>在正则的末尾加上’g’就好，’g’表示global，是全局匹配的意思。’g’是正则表达式的一个修饰符，修饰符有:</p><ul><li>‘g’: global 全文搜索，不添加的话，搜索到第一个停止</li><li>‘i’: ignore case 忽略大小写，默认大小写敏感</li><li>‘m’: multiple 多行搜索，检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用</li></ul><p>但是这样的话也改变了this中is的大小写，这显然不是我们想要的，所以这个时候可以这样做<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'He is a boy, This is a dog. Where is she?'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'IS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//He IS a boy, This IS a dog. Where IS she?</span></span><br></pre></td></tr></table></figure><p></p><p>‘\b’:匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。这里的正则在’is’的前后都有’\b’，这样就只能匹配单词’is’了。</p><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h3><p>倘若你需要使用构造函数的方式实例化正则，则上面的字面量形式可以改成这样：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\bis\\b'</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'He is a boy, This is a dog. Where is she?'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'IS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//He IS a boy, This IS a dog. Where IS she?</span></span><br></pre></td></tr></table></figure><p></p><p>用这种方式就不需要’/‘符号开始和结尾以表示是正则了。但是里面的’\’等特殊字符需要用’\’转义。</p><p>“\”:将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\ \”匹配“\”而“\ (”则匹配“(”。</p><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><hr><p>正则表达式由两种基本字符类型组成：</p><ul><li>原义文本字符，即代表它原本含义的字符</li><li>元字符，元字符是在正则表达式中有特殊含义的非字母字符，例如上文提到的’\b’，表示匹配单词边界，并不是匹配’\b’，在正则中主要存在这些特殊字符：*,+,?,$,^,.,|,\,(,),{,},[,]</li></ul><h3 id="字符类（字符集合）"><a href="#字符类（字符集合）" class="headerlink" title="字符类（字符集合）"></a>字符类（字符集合）</h3><hr><p>一般情况下，正则表达式一个字符对应字符串一个字符</p><blockquote><p>思考： var text = ‘a1b2c3d4’; 把英文字母都换成X</p></blockquote><p>但是更多的时候，我们匹配的并不是某个字符，而是符合一系列特征的字符串。这时候，我们就可以使用元字符’[]’来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符，例如：表达式’[abc]’把字符a或b或c归为一类，表达式可以匹配这样的字符。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[abc]/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'a1b2c3d4'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'X'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//X1X2X3d4</span></span><br></pre></td></tr></table></figure><p></p><h4 id="字符类取反"><a href="#字符类取反" class="headerlink" title="字符类取反"></a>字符类取反</h4><p>使用元字符’^’创建 反向类/负向类。反向类的意思是不属于类的内容，表达式’[^abc]’表示不是字符a或b或c的内容,例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[^abc]/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'a1b2c3d4'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'X'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//aXbXcXXX</span></span><br></pre></td></tr></table></figure><p></p><h3 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h3><hr><blockquote><p>思考： var text = ‘a1b2c3d4z9’; 把英文字母都换成Q</p></blockquote><p>倘若我们需要用字符类匹配数字，按照前面的匹配方式，书写可能会很麻烦，需要这样：’[0123456789]’，对于 a 到 z 的字符更是如此。</p><p>为此，正则表达式给我们提供了范围类，我们可以使用[a-z]来连接两个字符，表示从a到z的任意字符，这是一个闭区间，包含 a 和 z 本身。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'a1b2c3d4z9'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'Q'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//Q1Q2Q3Q4Q9</span></span><br></pre></td></tr></table></figure><p></p><p>可以发现，这样就方便了许多。此外，在’[]’组成的类的内部是可以连写的[a-zA-Z]，这样就形成了大写字母小写字母完全匹配:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-zA-Z]/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'a1b2c3d4z9ASDFHDFH'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'Q'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//Q1Q2Q3Q4Q9QQQQQQQQ</span></span><br></pre></td></tr></table></figure><p></p><h3 id="预定义类及边界"><a href="#预定义类及边界" class="headerlink" title="预定义类及边界"></a>预定义类及边界</h3><hr><h4 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h4><blockquote><p>思考： 匹配一个 ab+数字+任意字符 的字符串：</p></blockquote><p>正则表达式提供预预定义类来匹配常见的字符类，让我们书写更方便。</p><table><thead><tr><th>字符</th><th>等价类</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>[^\r\n]</td><td>除了回车符和换行符之外的所有字符</td></tr><tr><td>\d</td><td>[0-9]</td><td>数字字符</td></tr><tr><td>\D</td><td>[^0-9]</td><td>非数字字符</td></tr><tr><td>\s</td><td>[\t\n\x0B\f\r]</td><td>空白符</td></tr><tr><td>\S</td><td>[^\t\n\x0B\f\r]</td><td>非空白符</td></tr><tr><td>\w</td><td>[a-zA-Z_0-9]</td><td>单词字符（字母、数字、下划线）</td></tr><tr><td>\w</td><td>[a-zA-Z_0-9]</td><td>单词字符（字母、数字、下划线）</td></tr><tr><td>\W</td><td>[^a-zA-Z_0-9]</td><td>非单词字符</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab\d./</span>; <span class="comment">//之前我们可能会这样写：ab[0-9][^\r\n]</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'absdlkjflab91323'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'AAAA'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//absdlkjflAAAA323</span></span><br></pre></td></tr></table></figure><h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><blockquote><p>思考： var text = ‘He is a boy, This is a dog. Where is she?’; 我们在第一个例子中用到过’\b’单词边界，这里我们做一个跟上面第一个例子相反的，只把’This’中的’is’替换为’IS’</p></blockquote><p>除了预定义类，正则表达式还提供了几个常用的边界字符。</p><table><thead><tr><th>字符</th><th>等价类</th></tr></thead><tbody><tr><td>^</td><td>以xxx开始</td></tr><tr><td>$</td><td>以xxx结束</td></tr><tr><td>\b</td><td>单词边界</td></tr><tr><td>\B</td><td>非单词边界</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\Bis\b/g;</span><br><span class="line">var text = &apos;He is a boy, This is a dog. Where is she?&apos;;</span><br><span class="line">var result = text.replace(reg,&apos;IS&apos;);</span><br><span class="line">console.log(result) //He is a boy, ThIS is a dog. Where is she?</span><br></pre></td></tr></table></figure><p>在类’[]’中’^’表示取反，但是不在类中的时候’^’表示以xxx开始，’$’表示以xxx结束，这两个边界字符一般放在正则的开始和结束位置。</p><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><hr><p>倘若我们希望匹配一个连续出现20次的数字的字符串，通过我们之前学习的知识，我们可能会写出连续20个’\d’。假如20次你还可以接受，那100次，1000次，甚至更多次，你怎么办？<br>为了解决这个问题，正则表达式引入了量词的概念，下面是一些量词和他们的含义：</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>？</td><td>出现零次或一次（最多出现一次）</td></tr><tr><td>+</td><td>出现一次或者多次（至少出现一次</td></tr><tr><td>*</td><td>出现零次或者多次（任意次）</td></tr><tr><td>{n}</td><td>出现n次</td></tr><tr><td>{n,m}</td><td>出现n到m次</td></tr><tr><td>{n,}</td><td>至少出现n次</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\d&#123;4&#125;[/-]\d&#123;2&#125;[/-]\d&#123;2&#125;/g;</span><br><span class="line">var text = &apos;2018-02-23，2018/02/24，2018~02/25&apos;;</span><br><span class="line">var result = text.replace(reg,&apos;匹配正确日期格式&apos;);</span><br><span class="line">console.log(result);//匹配正确日期格式，匹配正确的日期格式，2018~02/25</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><hr><blockquote><p>思考： var text = ‘ByronByronByronnn’;将单词Byron替换为数字0</p></blockquote><p>匹配字符串 Byron 连续出现3次的场景，根据前面所了解的，我们可能会这样写：Byron{3}。<br>但是这样是错误的，试试你会发现只有Byronnn才能匹配成功，即最后的n重复了3次，并不能匹配整个单词重复三次的情况：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /Byron&#123;3&#125;/g;</span><br><span class="line">var text = &apos;ByronByronByronnn&apos;;</span><br><span class="line">var result = text.replace(reg,&apos;0&apos;);</span><br><span class="line">console.log(result);//ByronByron0</span><br></pre></td></tr></table></figure><p></p><p>那么，我们要怎么匹配Byron连续出现3次的情况呢，这时候，正则表达式的分组’()’就帮我们解决了这个问题：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(Byron)&#123;3&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'ByronByronByronnn'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//0nn</span></span><br></pre></td></tr></table></figure><p></p><h4 id="或"><a href="#或" class="headerlink" title="或"></a>或</h4><p>有时候，我们可能会需要在匹配时用到或者的关系，利用之前的’[]’字符类（字符集合）可能只能匹配单个字符的或者关系，比如匹配a或b，你可以这样写：’[ab]’，但是如果你需要匹配的是一整个单词的或者关系呢，这个时候’[]’就不好使了。这时候，我们用’|’可以达到或的效果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//匹配单词Byron或者Casper</span><br><span class="line">var reg = /Byron|Casper/g;</span><br><span class="line">var text = &apos;ByronCasper&apos;</span><br><span class="line">var result = text.replace(reg,&apos;X&apos;);</span><br><span class="line">console.log(result);//XX</span><br><span class="line"></span><br><span class="line">//匹配Byr+on或Ca+sper</span><br><span class="line">var reg = /Byr(on|Ca)sper/g;</span><br><span class="line">var text = &apos;ByronsperByrCasper&apos;</span><br><span class="line">var result1 = text.replace(reg,&apos;X&apos;);</span><br><span class="line">console.log(result1);//XX</span><br></pre></td></tr></table></figure><p></p><h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><blockquote><p>思考：把日期’2015-12-25’替换成’12/25/2015’</p></blockquote><p>这时候，正则的反向引用就可以取到作用了。表达式在匹配时，表达式引擎会将小括号 “( )” 包含的表达式所匹配到的字符串记录（分组捕获）下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。</p><p>在js中正则匹配成功的字符串可以用$1表示第一次匹配成功，$3表示第三次匹配成功的字符，以此类推至$99）。于是，上面的例子就可以这样写了：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'2015-12-25'</span></span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'$2/$3/$1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//12/25/2015</span></span><br></pre></td></tr></table></figure><p></p><h4 id="忽略分组"><a href="#忽略分组" class="headerlink" title="忽略分组"></a>忽略分组</h4><p>在上面的反向引用中，我们默认是根据’()’全部捕获记录为$1~$99的，倘若我们想忽略某个捕获要怎么办呢？</p><p>不希望捕获某些分组，只需要在分组内加上’?:’就可以了。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?:Byron)(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'Byron2016-12-05'</span></span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'$2/$3/$1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//12/05/2016</span></span><br></pre></td></tr></table></figure><p></p><h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><hr><blockquote><p>思考： var reg1 = /\w/; var reg2 = /\w/g;那么reg1.test(‘a’)和 reg2.test(‘ab’)的结果分别是什么？</p></blockquote><p>我们在用正则表达式相关的方法时，经常会用到正则表达式相关的一些对象属性，下面我们总结一下正则表达式相关的对象属性：</p><ul><li>golbal: 是否全文搜索，默认false</li><li>ignore case: 是否大小写敏感，默认false</li><li>multiline: 多行搜索，默认false</li><li>lastIndex: 是当前表达式匹配内容的最后一个字符的下一个位置</li><li>source: 正则表达式的文本字符串</li></ul><p>其中前面三个我们在上文中已经提到过了，source的话，我们一起结合起来看看代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\w/</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/\w/gim</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg1.global);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg1.ignoreCase);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg1.multiline);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg2.global);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.ignoreCase);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.multiline);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg1.source);<span class="comment">//\w</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.source);<span class="comment">//\w</span></span><br></pre></td></tr></table></figure><p></p><h3 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h3><hr><p>支持正则表达式的 String 对象的方法有：</p><ul><li>search： 检索与正则表达式相匹配的值</li><li>match： 找到一个或多个正则表达式的匹配。</li><li>replace： 替换与正则表达式匹配的子串。</li><li>split： 把字符串分割为字符串数组。<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式匹配的子字符串<br>语法为stringObject.search(regexp),结果返回 stringObject 中第一个与 regexp 相匹配的子串的起始位置index，如果没有找到任何匹配的子串，则返回 -1。需要注意的是，search() 方法不执行全局匹配，它将忽略修饰符’g’,并且总是从字符串的开始进行检索。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a1b2c3d4'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">'1'</span>)); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">'10'</span>)); <span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/b2/</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/\w\d/g</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/\w\d/g</span>)); <span class="comment">//0 忽略'g',执行多次未返回不同结果</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p>match() 方法将检索字符串，以找到一个或多个与 RegExp 匹配的文本，在 RegExp 是否有修饰符’g’影响很大。它返回指定的值，而不是字符串的位置。</p><p>语法为stringObject.match(searchvalue)或stringObject.match(regexp)，结果返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p><h4 id="1-非全局调用"><a href="#1-非全局调用" class="headerlink" title="1.非全局调用"></a>1.非全局调用</h4><ul><li>如果 regexp 没有标志 g ，那么 match() 方法就只能在字符串中执行匹配一次</li><li>如果没有找到任何匹配文本，返回 null</li><li>否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息：</li><li>数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/\d(\w)\d/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'1a2b3c4d5e'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.match(reg3);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//  [1a2, a]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="全局调用"><a href="#全局调用" class="headerlink" title="全局调用"></a>全局调用</h4><p>全局调用就和 exec() 不同了：</p><ul><li>如果 regexp 具有标志 g 则 match() 方法将执行全局检索，找到字符串中所有匹配的子字符串</li><li>没有找到任何匹配的子字符串则返回 null</li><li>如果找到了一个或者多个匹配字串，则返回一个数组</li><li>数组元素中存放的是字符串中所有匹配的字串，而且也没有index属性和input属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg4 = <span class="regexp">/\d(\w)(\w)\d/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'$1az2bb3cy4dd5ee'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.match(reg4)</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["1az2", "3cy4"]</span></span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>我们经常用它把字符串分割为数组。但是你可能不知道，我们在一些复杂情况下我们可以使用正则表达式解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a,b,c,d'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.split(<span class="string">','</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//['a','b','c','d']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--那如果是这样的字符串呢--&gt;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'a1b2c3d'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.split(<span class="regexp">/\d/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//['a','b','c','d']</span></span><br></pre></td></tr></table></figure><blockquote><p>其实，我们在用 split() 分割字符’,’的时候，split() 方法也是把’,’ 隐士转换成正则’/,/‘的, search() 方法和 replace() 方法也是一样的。</p></blockquote><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。<br>语法为stringObject.replace(regexp/substr,replacement),结果返回一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。</p></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/linhui.github.io/js中this的指向/" rel="next" title="js中this的指向"><i class="fa fa-chevron-left"></i> js中this的指向</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/linhui.github.io/Promise的作用以及基本使用/" rel="prev" title="Promise的作用以及基本使用">Promise的作用以及基本使用 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">林晖</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/linhui.github.io/archives/"><span class="site-state-item-count">11</span> <span class="site-state-item-name">posts</span></a></div></nav><div class="feed-link motion-element"><a href="/linhui.github.io/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。"><span class="nav-number">1.</span> <span class="nav-text">正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。</span></a></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#RegExp对象"><span class="nav-number"></span> <span class="nav-text">RegExp对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-字面量"><span class="nav-number"></span> <span class="nav-text">1.字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-构造函数"><span class="nav-number"></span> <span class="nav-text">2.构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元字符"><span class="nav-number"></span> <span class="nav-text">元字符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符类（字符集合）"><span class="nav-number"></span> <span class="nav-text">字符类（字符集合）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符类取反"><span class="nav-number">1.</span> <span class="nav-text">字符类取反</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#范围类"><span class="nav-number"></span> <span class="nav-text">范围类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预定义类及边界"><span class="nav-number"></span> <span class="nav-text">预定义类及边界</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预定义类"><span class="nav-number">1.</span> <span class="nav-text">预定义类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#边界"><span class="nav-number">2.</span> <span class="nav-text">边界</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#量词"><span class="nav-number"></span> <span class="nav-text">量词</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组"><span class="nav-number"></span> <span class="nav-text">分组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#或"><span class="nav-number">1.</span> <span class="nav-text">或</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#反向引用"><span class="nav-number">2.</span> <span class="nav-text">反向引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略分组"><span class="nav-number">3.</span> <span class="nav-text">忽略分组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象属性"><span class="nav-number"></span> <span class="nav-text">对象属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持正则表达式的-String-对象的方法"><span class="nav-number"></span> <span class="nav-text">支持正则表达式的 String 对象的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#search"><span class="nav-number">1.</span> <span class="nav-text">search</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#match"><span class="nav-number">2.</span> <span class="nav-text">match</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-非全局调用"><span class="nav-number">3.</span> <span class="nav-text">1.非全局调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#全局调用"><span class="nav-number">4.</span> <span class="nav-text">全局调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#split"><span class="nav-number"></span> <span class="nav-text">split</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#replace"><span class="nav-number"></span> <span class="nav-text">replace</span></a></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">林晖</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/linhui.github.io/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/linhui.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/linhui.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/linhui.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/linhui.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/linhui.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/linhui.github.io/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/bootstrap.js?v=5.1.4"></script></body></html>