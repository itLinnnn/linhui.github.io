<!DOCTYPE html><html class="theme-next pisces use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/linhui.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/linhui.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/linhui.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/linhui.github.io/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/linhui.github.io/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/linhui.github.io/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/linhui.github.io/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="Hexo, NexT"><link rel="alternate" href="/linhui.github.io/atom.xml" title="林晖的个人博客" type="application/atom+xml"><meta property="og:type" content="website"><meta property="og:title" content="林晖的个人博客"><meta property="og:url" content="https://itlinnnn.github.io/linhui.github.io/index.html"><meta property="og:site_name" content="林晖的个人博客"><meta property="og:locale" content="default"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="林晖的个人博客"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/linhui.github.io/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://itlinnnn.github.io/linhui.github.io/"><title>林晖的个人博客</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="default"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/linhui.github.io/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">林晖的个人博客</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/linhui.github.io/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/linhui.github.io/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/浏览器缓存/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/浏览器缓存/" itemprop="url">浏览器缓存</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-22T15:38:05+08:00">2018-12-22</time></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>之前一直知道有浏览器缓存的概念，但是并不能较为具体的描述出来。在经过数次用户反馈bug修复线上并没有什么作用时，不想每次给出的方案都是清理缓存···，为了不再这么尴尬，自己决定把缓存这一块的知识点进行一个小整理。今天先来了解一下浏览器端的缓存</p></blockquote><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>缓存这东西，第一次必须获取到资源后，然后根据返回的信息来告诉如何缓存资源，可能采用的是强缓存，也可能告诉客户端浏览器是协商缓存，这都需要根据响应的header内容来决定的，下面用两幅图来描述浏览器的缓存原理。</p><ul><li>浏览器第一次请求时<br><img src="https://user-gold-cdn.xitu.io/2018/12/22/167d4ad0c0ec1c73?w=411&amp;h=369&amp;f=png&amp;s=20300" alt=""></li><li>浏览器在后续缓存时</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/22/167d4b15e9669632?w=554&amp;h=528&amp;f=png&amp;s=41705" alt=""></p><p>从上图可以知道，浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时：</p><p>1.浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；这也就是即使线上资源更新了显示还是没有及时更新的原因</p><p>2.如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容</p><h4 id="强缓存与协商缓存的区别，可以用下表来进行描述："><a href="#强缓存与协商缓存的区别，可以用下表来进行描述：" class="headerlink" title="强缓存与协商缓存的区别，可以用下表来进行描述："></a>强缓存与协商缓存的区别，可以用下表来进行描述：</h4><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">获取资源形式</th><th style="text-align:left">状态码</th><th style="text-align:left">发送请求到服务器</th></tr></thead><tbody><tr><td style="text-align:left">强缓存</td><td style="text-align:left">从缓存取</td><td style="text-align:left">200（from cache）</td><td style="text-align:left">否，直接从缓存取</td></tr><tr><td style="text-align:left">协商缓存</td><td style="text-align:left">从缓存取</td><td style="text-align:left">304（not modified）</td><td style="text-align:left">是，正如其名，通过服务器来告知缓存是否可用</td></tr></tbody></table><h3 id="强缓存相关的header字段"><a href="#强缓存相关的header字段" class="headerlink" title="强缓存相关的header字段"></a>强缓存相关的header字段</h3><blockquote><p>强缓存上面已经介绍了，直接从缓存中获取资源而不经过服务器；与强缓存相关的header字段有两个：</p></blockquote><ol><li>expires，这是http1.0时的规范；它的值为一个绝对时间的GMT格式的时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源</li><li>cache-control：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对值；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行；cache-control除了该字段外，还有下面几个比较常用的设置值：</li></ol><ul><li><p>no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</p></li><li><p>no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</p></li><li><p>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</p></li><li><p>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</p></li></ul><blockquote><p>注意：如果cache-control与expires同时存在的话，cache-control的优先级高于expires</p></blockquote><h3 id="3协商缓存相关的header字段"><a href="#3协商缓存相关的header字段" class="headerlink" title="3协商缓存相关的header字段"></a>3协商缓存相关的header字段</h3><p>协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是成对出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。</p><ol><li>Last-Modified/If-Modified-Since<br>二者的值都是GMT格式的时间字符串，具体过程：<ul><li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间</li><li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值</li><li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header</li></ul></li></ol><ul><li>浏览器收到304的响应后，就会从缓存中加载资源</li><li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值</li></ul><ol start="2"><li>Etag/If-None-Match<br>这两个值是由服务器生成的每个资源的唯一标识字符串，只要资源有变化就这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。</li></ol><h3 id="Last-Modified-Etag"><a href="#Last-Modified-Etag" class="headerlink" title="Last-Modified / Etag"></a>Last-Modified / Etag</h3><p>你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：</p><ul><li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET</li><li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；</li><li>某些服务器不能精确的得到文件的最后修改时间。</li></ul><p>这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。</p><p>Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p><h3 id="用户的行为对缓存的影响"><a href="#用户的行为对缓存的影响" class="headerlink" title="用户的行为对缓存的影响"></a>用户的行为对缓存的影响</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/22/167d4cdc70a5dd0e?w=639&amp;h=205&amp;f=png&amp;s=2025" alt=""></p><h3 id="强缓存如何重新加载缓存缓存过的资源"><a href="#强缓存如何重新加载缓存缓存过的资源" class="headerlink" title="强缓存如何重新加载缓存缓存过的资源"></a>强缓存如何重新加载缓存缓存过的资源</h3><blockquote><p>上面说到，使用强缓存时，浏览器不会发送请求到服务端，根据设置的缓存时间浏览器一直从缓存中获取资源，在这期间若资源产生了变化，浏览器就在缓存期内就一直得不到最新的资源，那么如何防止这种事情发生呢？</p></blockquote><h4 id="通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。"><a href="#通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。" class="headerlink" title="通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。"></a>通过更新页面中引用的资源路径，让浏览器主动放弃缓存，加载新资源。</h4><p>这样每次文件改变后就会生成新的query值，这样query值不同，也就是页面引用的资源路径不同了，之前缓存过的资源就被浏览器忽略了，因为资源请求的路径变了</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/为vue的项目添加单元测试/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/为vue的项目添加单元测试/" itemprop="url">为vue的项目添加单元测试</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-18T09:26:58+08:00">2018-12-18</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><ul><li>单元测试能避免出现一些代码运行结果与预期不符的错误，通常是一些比较低级但又难以发现的问题。</li><li>粗心且懒，在每次调整之后，需要不断地检查代码，反复去走流程。担心由于自己的改动而导致了逻辑上的错误。而这里面的一大部分工作其实可以让单元测试来完成。</li><li>有了单元测试之后，可以对代码本身形成一种规范。如果在进行单元测试过程中发现自己的一些代码不方便进行测试，那么你可能需要重新审视这些代码，看是否有一些设计上不合理或者可以优化的地方。</li><li>嵌入了单元测试的项目显得更加的专业，也会更有逼格，测试本身是开发环节需要做的内容。</li></ul><h3 id="工具选取对比（一个合适测试框架-–-Jest）"><a href="#工具选取对比（一个合适测试框架-–-Jest）" class="headerlink" title="工具选取对比（一个合适测试框架 – Jest）"></a>工具选取对比（一个合适测试框架 – Jest）</h3><p>之前也没有去接触过前端的单元测试，也是这几天开始了解，开始并没有头绪，所以就在网上以及github上去看了一些之前比较流行的测试框架。发现比较流行的是karma + mocha + Chrome的组合。当我单独一个个去看的时候，发现其内容还是比较的多的。之后选取了jest也是经过对比权衡的</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>一站式的解决方案，学习成本更低，上手更快（很适合现如今我的需求）<blockquote><p>在使用 Jest 之前，我需要一个测试框架（mocha），需要一个测试运行器（karma），需要一个断言库（chai），需要一个用来做 spies/stubs/mocks 的工具（sinon 以及 sinon-chai 插件），一个用于测试的浏览器环境（可以是 Chrome 浏览器，也可以用 PhantomJS）。<br>而使用 Jest 后，只要安装它，全都搞定了。</p></blockquote></li><li>全面的官方文档，易于学习和使用<blockquote><p>Jest 的官方文档很完善，对着文档很快就能上手。而在之前，我需要学习好几个插件的用法，至少得知道 mocha 用处和原理吧 我得学会 karma 的配置和命令，chai 的各种断言方法……，经常得周旋于不同的文档站之间，其实是件很烦也很低效的事</p></blockquote></li><li>更直观明确的测试信息提示</li><li>方便的命令行工具</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>jsdom 的一些局限性：因为 Jest 是基于 jsdom 的，jsdom 毕竟不是真实的浏览器环境，它在测试过程中其实并不真正的“渲染”组件。这会导致一些问题，例如，如果组件代码中有一些根据实际渲染后的属性值进行计算（比如元素的 clientWidth）就可能出问题，因为 jsdom 中这些参数通常默认是 0.</p><hr><p>综上所述，最终我确定下来的方案是使用成熟好用的测试工具库 — vue-test-utils<br>其前身是 avoriaz，avoriaz 也是一个不错的包，但其 README 中有说明，当 vue-test-utils 正式发布的时候， 它将会被废弃。<br>vue-test-utils 能极大地简化 Vue.js 单元测试。<br>例如：Vue 单元测试，一般是像下面这样的（包括 vue-cli 提供的模板里默认也是这样）：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'HelloWorld.vue'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should render correct contents'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> Constructor = Vue.extend(HelloWorld)</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="keyword">new</span> Constructor().$mount()</span><br><span class="line">    expect(vm.$el.querySelector(<span class="string">'.hello h1'</span>).textContent)</span><br><span class="line">     .toEqual(<span class="string">'Welcome to Your Vue.js App'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>使用 vue-test-utils 后，你可以像下面这样<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'HelloWorld.vue'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should render correct contents'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallow(HelloWorld, &#123;</span><br><span class="line">      attachToDocument: ture</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    expect(wrapper.find(<span class="string">'.hello h1'</span>).text()).to.equal(<span class="string">'Welcome to Your Vue.js App'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>可以看到代码更加简洁了。wrapper 内含许多有用的方法，上面的例子中所使用的 find() 其中最简单不过的一个。vue-test-utils 还有 createLocalVue() 等方法以及 stub 之类的功能，基本上可以完成绝大部分情况下的测试用例,这也是非常的实用的了。</p><h4 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h4><p>安装使用的方式很简单，由于想引入到现有的项目中来，现有的项目大多是vue-cli创建的，所以一开始的时候基本上是已经安装并配置好了 webpack、vue-loader 和 Babel。如果是比较原始的项目，也是可以单独安装的。</p><ul><li><p>我们要做的第一件事就是安装 Jest 和 Vue Test Utils：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save-dev jest @vue/test-utils</span><br></pre></td></tr></table></figure></li><li><p>然后我们需要在 package.json 中定义一个单元测试的脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"jest"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 Jest 中处理单文件组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev vue-jest</span><br></pre></td></tr></table></figure></li><li><p>接下来在 package.json 中创建一个 jest 块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="string">"jest"</span>: &#123;</span><br><span class="line">    <span class="string">"moduleFileExtensions"</span>: [</span><br><span class="line">      <span class="string">"js"</span>,</span><br><span class="line">      <span class="string">"json"</span>,</span><br><span class="line">      <span class="comment">// 告诉 Jest 处理 `*.vue` 文件</span></span><br><span class="line">      <span class="string">"vue"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"transform"</span>: &#123;</span><br><span class="line">      <span class="comment">// 用 `vue-jest` 处理 `*.vue` 文件</span></span><br><span class="line">      <span class="string">".*\\.(vue)$"</span>: <span class="string">"vue-jest"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="具体的使用步骤"><a href="#具体的使用步骤" class="headerlink" title="具体的使用步骤"></a>具体的使用步骤</h4><hr><blockquote><p>此处我根据自己的需求来进行整理</p><ul><li>对页面内容的测试<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// viewTest.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;1212121&lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'viewTest'</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">'Welcome to Your Vue.js App'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// viewTest.spec</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'../../../src/components/viewTest'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'页面展示测试'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'检查元素是否存在'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(Component)</span><br><span class="line">    expect(wrapper.contains(<span class="string">'.hello h1'</span>)).toBe(<span class="literal">true</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(wrapper.find(<span class="string">'.hello h1'</span>).text())</span><br><span class="line">    expect(wrapper.text()).toContain(<span class="string">'Welcome'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个是最简单的对页面的dom节点的测试，以及可以对文案进行一些测试，这些是比较基础的</p><ul><li>对事件处理的测试<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;My To Do event&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;wawawawawawa&lt;/</span>h2&gt;</span><br><span class="line">        &lt;input v-model=<span class="string">"newItem"</span>&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"addItemToList"</span>&gt;Add&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>br&gt;</span><br><span class="line">        &lt;!--displays event --&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &lt;li v-<span class="keyword">for</span>=<span class="string">"item in listItems"</span>&gt;&#123;&#123; item &#125;&#125;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/u</span>l&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">      name: <span class="string">'event'</span>,</span><br><span class="line">      data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          listItems: [<span class="string">'buy food'</span>, <span class="string">'play games'</span>, <span class="string">'sleep'</span>],</span><br><span class="line">          newItem: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        addItemToList() &#123;</span><br><span class="line">          <span class="keyword">this</span>.listItems.push(<span class="keyword">this</span>.newItem);</span><br><span class="line">          <span class="keyword">this</span>.newItem = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.spec.js</span></span><br><span class="line"><span class="comment">// 从测试实用工具集中导入 `mount()` 方法</span></span><br><span class="line"><span class="comment">// 同时导入你要测试的组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">'../../../src/components/itemEvent'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'事件触发测试'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'事件触发测试'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 现在挂载组件，你便得到了这个包裹器</span></span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(Component)</span><br><span class="line">    <span class="keyword">const</span> button = wrapper.find(<span class="string">'button'</span>)</span><br><span class="line">    wrapper.setData(&#123;</span><br><span class="line">      newItem: <span class="string">'添加测试项'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    button.trigger(<span class="string">'click'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(wrapper.text())</span><br><span class="line">    expect(wrapper.text()).toContain(<span class="string">'添加测试项'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>这里是在模拟用户交互的一个测试，当用户点击按钮的时候会把数据插入到当前的列表中来，所以最开始需要定位到这个按钮，可以用find()，之后要去触发这个事件， button.trigger(‘click’)，然后把预期的结果，与按照流程的结果相比较，以达到测试的效果。这里模拟的是一个点击事件，当然，api也支持各种的鼠标事件以及键盘事件。</p><ul><li>测试异步行为<br>平时的业务场景中肯定是离不开异步操作的，当发送一个接口请求的时候应该怎么去才做。Jest 运行测试用例同时可以模拟了 HTTP 库 axios，对预期结果可以进行设定和比较，比如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// axios.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  get: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">data</span>: <span class="string">'response'</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=<span class="string">"fetchResults"</span>&gt;发送请求&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123;value&#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import axios from '../</span>axios.js<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  data () &#123;</span></span><br><span class="line"><span class="string">    return &#123;</span></span><br><span class="line"><span class="string">      value: '</span>初始值<span class="string">'</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  methods: &#123;</span></span><br><span class="line"><span class="string">    async fetchResults () &#123;</span></span><br><span class="line"><span class="string">      const response = await axios.get('</span>mock/service<span class="string">')</span></span><br><span class="line"><span class="string">      this.value = response.data</span></span><br><span class="line"><span class="string">      console.log(this.value)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;, </span></span><br><span class="line"><span class="string">  created ()&#123;</span></span><br><span class="line"><span class="string">    console.log(axios.get)</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async.spec.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">async</span> <span class="keyword">from</span> <span class="string">'../../../src/components/async'</span></span><br><span class="line">jest.mock(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line">it(<span class="string">'当点击按钮发送请求时检验返回值'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallowMount(<span class="keyword">async</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(jest)</span><br><span class="line">  wrapper.find(<span class="string">'button'</span>).trigger(<span class="string">'click'</span>)</span><br><span class="line">  <span class="comment">// expect(wrapper.value)</span></span><br><span class="line">  expect(wrapper.vm.value).toBe(<span class="string">'response'</span>)</span><br><span class="line">  <span class="comment">// console.log(wrapper.vm.value).toBe('初始值')</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这个时候运行的话会报错误<br><img src="https://user-gold-cdn.xitu.io/2018/12/18/167beb8a057b1c56?w=1548&amp;h=274&amp;f=png&amp;s=54188" alt=""><br>因为断言在 fetchResults 中的 Promise 完成之前就被调用了，所以value的值还是最开始的初始值。大多数单元测试库都提供一个回调来使得运行期知道测试用例的完成时机。Jest 和 Mocha 都是用了 done。我们可以和 $nextTick 或 setTimeout 结合使用 done 来确保任何 Promise 都会在断言之前完成。</p><ul><li>测试 Vue Router 使用</li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/使用es6写出更简洁的js/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/使用es6写出更简洁的js/" itemprop="url">使用es6写出更简洁的js</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-09T12:51:35+08:00">2018-12-09</time></span></div></header><div class="post-body" itemprop="articleBody"><p>使用新语法配合 babel 的转码，已经可以解决一些浏览器的兼容问题了。既然如此，那就可以在具体的业务中多使用新语法去探索一下怎么更好的去写代码吧。分享下个人开发中整理的常用的 js 写法技巧</p><h3 id="使用-let-const"><a href="#使用-let-const" class="headerlink" title="使用 let / const"></a>使用 let / const</h3><p>var 命令会发生”变量提升“现象，即变量可以在声明之前使用，值为 undefined。<br>个人认为，对声明的变量确定后面不会发生更改时，使用 const, 这样代码的可读性也会增强。</p><ul><li>const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</li><li>let 变量指向的内存地址，保存的只是一个指向实际数据的指针<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">补充 <span class="keyword">const</span> 定义的变量不是数据不可变，而是保存的引用地址不能发生改变。例子如下：</span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line">person.age = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age ) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p><p>好处是：解决了访问多层嵌套的对象或数组的命名，减少代码量</p><ul><li><p>声明多个变量:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [age, name, sex] = [<span class="number">22</span>, <span class="string">'paopao'</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(age, name, sex) <span class="comment">// 22, paopao, 1</span></span><br></pre></td></tr></table></figure></li><li><p>使用在对象中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    firstName: <span class="string">'da'</span>,</span><br><span class="line">    lastName: <span class="string">'paopao'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; firstName, lastName &#125; = obj.name <span class="comment">// 如果我们多处使用 firstName， 那就不必要每个地方都写 obj.name.firstName, 极大提升代码效率</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> firstName = obj.name.firstName</span><br><span class="line"><span class="keyword">const</span> lastName = obj.name.lastName</span><br></pre></td></tr></table></figure></li><li><p>使用在函数中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在参数中结构赋值，获取参数, 当参数多的使用时候十分方便</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Destructuring</span>(<span class="params">&#123; name, age &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; name, age &#125; <span class="comment">// 相当于 &#123; name: name, age: age &#125; , 可以简写</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'dapaopao'</span>, <span class="attr">age</span>: <span class="number">22</span> &#125;</span><br><span class="line">Destructuring(obj)</span><br></pre></td></tr></table></figure></li></ul><h3 id="扩展符的运用"><a href="#扩展符的运用" class="headerlink" title="扩展符的运用"></a>扩展符的运用</h3><p>es6 扩展符有很多用法，他可以使你的代码更加简洁，易懂。这里就举例常用的用法</p><ul><li><p>在对象中的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'dapaopao'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  sex: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制对象。扩展符为浅复制！！！</span></span><br><span class="line"><span class="keyword">const</span> copy = &#123; ...obj &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改对象属性值(生成新对象) 相当于 Object.assgin(&#123;&#125;, obj, &#123; age: 18 &#125;)</span></span><br><span class="line"><span class="keyword">const</span> newObj = &#123; ...obj, <span class="attr">age</span>: <span class="number">18</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合结构赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123; sex, ...z &#125; = obj</span><br><span class="line">z <span class="comment">// &#123; name: 'dapaopao', age: 22 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在数组中的用法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制数组。扩展符为浅复制！！！</span></span><br><span class="line"><span class="keyword">const</span> newArr = [...arr] <span class="comment">// ...[1, 2, 3] =&gt; 相当于展开数组：1, 2, 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并数组</span></span><br><span class="line"><span class="keyword">const</span> conbineArr = [...arr, ...arr2]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合求最大值函数</span></span><br><span class="line"><span class="built_in">Math</span>.max(...arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合 Set 实现数组去重。注意：json 等对象数组不可用</span></span><br><span class="line">[...new <span class="built_in">Set</span>(arr2)] <span class="comment">// [4, 5, 6]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="数组用法"><a href="#数组用法" class="headerlink" title="数组用法"></a>数组用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">// 判断是否为数组</span></span><br><span class="line"></span><br><span class="line">arr.includes(<span class="number">2</span>) <span class="comment">// true 判断数组中是否包含某项</span></span><br><span class="line"></span><br><span class="line">arr.findIndex(<span class="function"><span class="params">d</span> =&gt;</span> d === <span class="number">3</span>) <span class="comment">// 2 找出第一个符合条件的数组成员并返回数组下标, 找不到返回 -1</span></span><br><span class="line"></span><br><span class="line">arr.find(<span class="function"><span class="params">d</span> =&gt;</span> d === <span class="number">3</span>) <span class="comment">// 3 找出第一个符合条件的数组成员并返回, 找不到返回 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es5 其他还有 filter map forEach 等，这里不做举例。</span></span><br><span class="line">arr.every(<span class="function"><span class="params">d</span> =&gt;</span> d &gt; <span class="number">2</span>) <span class="comment">// false 每一项都满足条件则返回 true</span></span><br><span class="line"></span><br><span class="line">arr.some(<span class="function"><span class="params">d</span> =&gt;</span> d &gt; <span class="number">2</span>) <span class="comment">// true 只要有一项满足条件则返回 true</span></span><br></pre></td></tr></table></figure><p>find/findIndex : 找出第一个符合条件的数组成员之后不再匹配，一定程度下优化查找。 includes: 返回 true/false, 相较于 indexOf, 实用多了</p><ul><li><p>flat() : 扁平化数组，常用于将数组转化为一维数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">arr.flat() <span class="comment">// [1, 2, 3, 4] 扁平化数组, 默认展开一层。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]]</span><br><span class="line"></span><br><span class="line">arr2.flat() <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line">arr2.flat(<span class="number">2</span>) <span class="comment">// [1, 2, 3, 4, 5, 6] flat(3) 也是展开两层...</span></span><br></pre></td></tr></table></figure></li><li><p>flatMap(): 在数组执行 map 方法后执行 flat, 用的不多，其实可以写 map 后写 flat 更好懂点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].flatMap(<span class="function"><span class="params">x</span> =&gt;</span> [x, x * <span class="number">2</span>]) <span class="comment">//  [ 2, 4, 3, 6, 4, 8 ]</span></span><br><span class="line"><span class="comment">// 1. [2, 3, 4].map(d =&gt; [d, d * 2]) =&gt; [[2, 4], [3, 6], [4, 8]]</span></span><br><span class="line"><span class="comment">// 2. [[2, 4], [3, 6], [4, 8]].flat()</span></span><br></pre></td></tr></table></figure></li></ul><p>补充常用的对象转数组的用法：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'dapaopao'</span> &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">Object</span>.keys(obj) <span class="comment">// ['name']</span></span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// ['dapaopao']</span></span><br><span class="line"><span class="built_in">Object</span>.entries(obj) <span class="comment">// ['name', 'dapaopao']</span></span><br></pre></td></tr></table></figure><p></p><h3 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h3><p>用的挺多的，但是不兼容 IE !<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'dapaopao'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newStr = <span class="string">`welcome <span class="subst">$&#123;name&#125;</span>`</span> <span class="comment">// welcome dapaopao</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the same as</span></span><br><span class="line"><span class="keyword">const</span> newStr = <span class="string">'welcome '</span> + name</span><br></pre></td></tr></table></figure><p></p><h3 id="使用-async-await"><a href="#使用-async-await" class="headerlink" title="使用 async / await"></a>使用 async / await</h3><blockquote><p>这里做个例子进行介绍<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> axios.get(<span class="string">'https://randomuser.me/api/'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  axios.get(<span class="string">'https://randomuser.me/api/'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res)) <span class="comment">// axios 也是 promise 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><h3 id="优化-if-else-语句"><a href="#优化-if-else-语句" class="headerlink" title="优化 if/else 语句"></a>优化 if/else 语句</h3><blockquote><p>当逻辑或||时，找到为 true 的分项就停止处理，并返回该分项的值，否则执行完，并返回最后分项的值。 当逻辑与&amp;&amp;时，找到为 false 的分项就停止处理，并返回该分项的值。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">0</span> || <span class="literal">null</span> || <span class="number">3</span> || <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">3</span> &amp;&amp; <span class="number">4</span> &amp;&amp; <span class="literal">null</span> &amp;&amp; <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// null</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p>减少 if / else地狱般的调用<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [age, name, sex] = [<span class="number">22</span>, <span class="string">'dapaopao'</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (age &gt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'dapaopao'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (sex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'all right'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 &amp;&amp;</span></span><br><span class="line"><span class="keyword">if</span> (age &gt; <span class="number">10</span> &amp;&amp; name === <span class="string">'dapaopao'</span> &amp;&amp; sex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'all right'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者(太长了不推荐)</span></span><br><span class="line">age &gt; <span class="number">10</span> &amp;&amp; name === <span class="string">'dapaopao'</span> &amp;&amp; sex &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">console</span>.log(<span class="string">'all right'</span>)</span><br></pre></td></tr></table></figure><p></p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/canvas压缩图片以及卡片制作/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/canvas压缩图片以及卡片制作/" itemprop="url">canvas压缩图片以及卡片制作</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-03T10:36:30+08:00">2018-12-03</time></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>在做一些活动页的时候，经常会有一些需要上传图片的需求，并且还需要将图片以及生成的文字以及贴图生成一张卡可以供用户可以长按保存。这个需求之前完成过一次，最近又遇上了，使用的都是canvas来实现的。干脆整理出一篇博客出来。如果有更好的实现方法，欢迎提出一起探讨。</p></blockquote><hr><h3 id="使用canvas压缩图片"><a href="#使用canvas压缩图片" class="headerlink" title="使用canvas压缩图片"></a>使用canvas压缩图片</h3><p>在html中使用写入input标签，type为file时候，可以调出手机的相册可供选择照片，也可以支持摄像头进行拍照功能。在这个场景下，就可能出现图片的体积会更大，可能会超出后端所支持的最大范围，从而导致上传失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input id=<span class="string">"file"</span> type=<span class="string">"file"</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="1-首先要先获取到图片文件"><a href="#1-首先要先获取到图片文件" class="headerlink" title="1.首先要先获取到图片文件"></a>1.首先要先获取到图片文件</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eleFile = <span class="built_in">document</span>.querySelector(<span class="string">'#file'</span>);</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">  eleFile.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    file = event.target.files[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">console</span>.log(file)</span><br><span class="line">    <span class="comment">// 选择的文件是图片</span></span><br><span class="line">    <span class="keyword">if</span> (file.type.indexOf(<span class="string">"image"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      reader.readAsDataURL(file);    </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="2-这个时候就取到了图片文件，就不得不了解一下js中FileReader对象的使用了"><a href="#2-这个时候就取到了图片文件，就不得不了解一下js中FileReader对象的使用了" class="headerlink" title="2.这个时候就取到了图片文件，就不得不了解一下js中FileReader对象的使用了"></a>2.这个时候就取到了图片文件，就不得不了解一下js中FileReader对象的使用了</h4><blockquote><p>FileReader对象允许Web应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容</p></blockquote><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><table><thead><tr><th>方法名</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>abort</td><td>none</td><td>中断读取</td></tr><tr><td>readAsBinaryString</td><td>file</td><td>二进制码</td></tr><tr><td>readAsDataURL</td><td>file</td><td>将文件读取为 DataURL</td></tr><tr><td>readAsText</td><td>file, [encoding]</td><td>将文件读取为文本</td></tr></tbody></table><ul><li>readAsText：该方法有两个参数，其中第二个参数是文本的编码方式，默认值为 UTF-8。这个方法非常容易理解，将文件以文本方式读取，读取的结果即是这个文本文件中的内容。</li><li>readAsBinaryString：该方法将文件读取为二进制字符串，通常我们将它传送到后端，后端可以通过这段字符串存储文件。</li><li>readAsDataURL：这是例子程序中用到的方法，该方法将文件读取为一段以 data: 开头的字符串，这段字符串的实质就是 Data URL，Data URL是一种将小文件直接嵌入文档的方案。这里的小文件通常是指图像与 html 等格式的文件。（其中base64的方式就是由此来获得的。。）</li></ul><h4 id="FileReader处理事件简介"><a href="#FileReader处理事件简介" class="headerlink" title="FileReader处理事件简介"></a>FileReader处理事件简介</h4><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>中断时触发</td></tr><tr><td>onerror</td><td>onabort</td></tr><tr><td>onload</td><td>文件读取成功完成时触发</td></tr><tr><td>onloadend</td><td>读取完成触发，无论成功或失败</td></tr><tr><td>onloadstart</td><td>读取开始时触发</td></tr><tr><td>onprogress</td><td>读取中</td></tr></tbody></table><blockquote><p>继续上面的操作，在拿到图片之后，需要将文件进行处理转化，此时<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(); </span><br><span class="line"><span class="comment">//将文件以Data URL形式读入页面 </span></span><br><span class="line">  reader.readAsDataURL(file); </span><br><span class="line">  reader.onload=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(reader)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>现在取到了图片也进行了转化，现在可以进行压缩了。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eleFile = <span class="built_in">document</span>.querySelector(<span class="string">'#file'</span>);</span><br><span class="line">  <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line">  eleFile.addEventListener(<span class="string">'change'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    file = event.target.files[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// console.log(file)</span></span><br><span class="line">    <span class="comment">// 选择的文件是图片</span></span><br><span class="line">    <span class="keyword">if</span> (file.type.indexOf(<span class="string">"image"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader(); </span><br><span class="line">      <span class="comment">//将文件以Data URL形式读入页面 </span></span><br><span class="line">        reader.readAsDataURL(file); </span><br><span class="line">        reader.onload=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">          <span class="comment">// console.log(this.result)</span></span><br><span class="line">          <span class="keyword">var</span> pre=<span class="built_in">document</span>.getElementById(<span class="string">"pre"</span>); </span><br><span class="line">          pre.setAttribute(<span class="string">"src"</span>, <span class="keyword">this</span>.result)</span><br><span class="line">          canvasDataURL(<span class="keyword">this</span>.result, <span class="number">100</span>, <span class="number">0.5</span>)</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">/* [canvasDataURL    通过canvas进行压缩]</span></span><br><span class="line"><span class="comment">   * @params path  图片的base64的格式</span></span><br><span class="line"><span class="comment">   * @params targetWidth  压缩后图片的宽度  </span></span><br><span class="line"><span class="comment">   * @params quality 图片质量  quality值越小，所绘制出的图像越模糊</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">canvasDataURL</span>(<span class="params">path, targetWidth, quality</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = path</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// var that = this</span></span><br><span class="line">        <span class="comment">// console.log(that)</span></span><br><span class="line">        <span class="comment">// 默认按比例压缩</span></span><br><span class="line">        <span class="keyword">var</span> w = <span class="keyword">this</span>.width</span><br><span class="line">        <span class="keyword">var</span> h = <span class="keyword">this</span>.height</span><br><span class="line">        scale = w / h;</span><br><span class="line">        w = targetWidth</span><br><span class="line">        h = targetWidth / scale</span><br><span class="line">        <span class="keyword">var</span> quality = quality;  <span class="comment">// 默认图片质量为0.7</span></span><br><span class="line">        <span class="comment">//生成canvas</span></span><br><span class="line">        <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">        <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">        <span class="comment">// 创建属性节点</span></span><br><span class="line">        <span class="keyword">var</span> anw = <span class="built_in">document</span>.createAttribute(<span class="string">"width"</span>);</span><br><span class="line">        anw.nodeValue = w;</span><br><span class="line">        <span class="keyword">var</span> anh = <span class="built_in">document</span>.createAttribute(<span class="string">"height"</span>);</span><br><span class="line">        anh.nodeValue = h;</span><br><span class="line">        canvas.setAttributeNode(anw);</span><br><span class="line">        canvas.setAttributeNode(anh);</span><br><span class="line">        ctx.drawImage(<span class="keyword">this</span>, <span class="number">0</span>, <span class="number">0</span>, w, h);</span><br><span class="line">        <span class="comment">// quality值越小，所绘制出的图像越模糊</span></span><br><span class="line">        <span class="keyword">var</span> base64 = canvas.toDataURL(<span class="string">'image/jpeg'</span>, quality);</span><br><span class="line">        <span class="keyword">var</span> result=<span class="built_in">document</span>.getElementById(<span class="string">"result"</span>); </span><br><span class="line">        result.setAttribute(<span class="string">"src"</span>, base64)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>很简单，这样就可以得到压缩后的图片了，从以上的代码可得知，原理在于canvas中的toDataURL方法可指定图片压缩后的格式及压缩质量，把canvas信息压缩并转为base64编码来实现压缩。</p><h3 id="使用canvas制作卡片"><a href="#使用canvas制作卡片" class="headerlink" title="使用canvas制作卡片"></a>使用canvas制作卡片</h3><p>场景：把刚刚压缩之后的图片与另一张图片相结合，可长按进行保存。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCanvas</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#myCanvas'</span>)</span><br><span class="line">   <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">   <span class="comment">// 是设备上物理像素和设备独立像素(device-independent pixels (dips))的比例</span></span><br><span class="line">   <span class="keyword">var</span> dp = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || <span class="number">1</span></span><br><span class="line">   <span class="keyword">var</span> ratio = <span class="keyword">this</span>.dp / <span class="keyword">this</span>.backingStoreRatio</span><br><span class="line">   <span class="keyword">var</span> oldWidth = canvas.width</span><br><span class="line">   <span class="keyword">var</span> oldHeight = canvas.height</span><br><span class="line">   canvas.width = oldWidth * ratio</span><br><span class="line">   canvas.height = oldHeight * ratio</span><br><span class="line">   canvas.style.width = oldWidth + <span class="string">'px'</span></span><br><span class="line">   canvas.style.height = oldHeight + <span class="string">'px'</span></span><br><span class="line">   ctx.scale(ratio, ratio)</span><br><span class="line">   <span class="keyword">var</span> headerImg = <span class="keyword">new</span> Image()</span><br><span class="line">   <span class="keyword">var</span> bgImg = <span class="keyword">new</span> Image()</span><br><span class="line">   headerImg.src = target</span><br><span class="line">   bgImg.src = <span class="string">'../bg.png'</span></span><br><span class="line">   headerImg.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">// 图片的宽高比</span></span><br><span class="line">     <span class="keyword">var</span> rate = headerImg.width / headerImg.height</span><br><span class="line">     <span class="built_in">console</span>.log(rate)</span><br><span class="line">     bgImg.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">       ctx.drawImage(headerImg, <span class="number">10</span>, <span class="number">30</span>, <span class="number">50</span>, (<span class="number">50</span> / rate))</span><br><span class="line">       <span class="comment">// 背景图片</span></span><br><span class="line">       ctx.drawImage(bgImg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">150</span>)</span><br><span class="line">       ctx.fillText(<span class="string">'厉害啊'</span>, <span class="number">80</span>, <span class="number">70</span>)</span><br><span class="line">       <span class="keyword">var</span> resultImg = <span class="keyword">new</span> Image()</span><br><span class="line">       resultImg.src = canvas.toDataURL(<span class="string">'image/png'</span>, <span class="number">1</span>)</span><br><span class="line">       resultImg.style.width = <span class="string">'100%'</span></span><br><span class="line">       <span class="keyword">var</span> cardImg=<span class="built_in">document</span>.getElementById(<span class="string">"cardImg"</span>); </span><br><span class="line">       cardImg.setAttribute(<span class="string">"src"</span>, resultImg.src)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p></p><p>取到刚刚得到的图片，在图像装载完毕时后将其画到画布上，也可以配上文字等等，最后也是把canvas的信息转为base64编码来进行实现<br>。可以通过代码来进行实践</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/iframe的使用/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/iframe的使用/" itemprop="url">iframe的使用</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-25T11:26:42+08:00">2018-11-25</time></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>开始接触前端的时候，搜索iframe出来的是iframe耗能，不安全等，以至于并没有去正式了解，想来也确实是太不够严谨。现在在业务中有需要用到iframe来实现一些特定的需求，所以觉得很有必要去了解一下，查了一些资料进行整理。</p></blockquote><h4 id="概念：-iframe-元素会创建包含另外一个文档的内联框架（即行内框架）-用于设置文本或图形的浮动图文框或容器"><a href="#概念：-iframe-元素会创建包含另外一个文档的内联框架（即行内框架）-用于设置文本或图形的浮动图文框或容器" class="headerlink" title="概念： iframe 元素会创建包含另外一个文档的内联框架（即行内框架）,用于设置文本或图形的浮动图文框或容器"></a>概念： iframe 元素会创建包含另外一个文档的内联框架（即行内框架）,用于设置文本或图形的浮动图文框或容器</h4><h4 id="基本使用："><a href="#基本使用：" class="headerlink" title="基本使用："></a>基本使用：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--这个是最通常的使用，还可以设置很多的属性值的--&gt;</span><br><span class="line">&lt;iframe src=<span class="string">"http://m.haimati.cn"</span>&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><blockquote><p>常用属性，会在下文中做一些介绍</p><ul><li>frameborder:是否显示边框，1(yes),0(no)</li><li>height:框架作为一个普通元素的高度，建议在使用css设置。</li><li>width:框架作为一个普通元素的宽度，建议使用css设置。</li><li>name:框架的名称，window.frames[name]时专用的属性。</li><li>scrolling:框架的是否滚动。yes,no,auto。</li><li>src：内框架的地址，可以使页面地址，也可以是图片的地址。</li><li>srcdoc , 用来替代原来HTML body里面的内容。但是IE不支持。</li><li>sandbox: 对iframe进行一些列限制，IE10+支持</li></ul></blockquote><h4 id="基本的特性：-能自由操作iframe和父框架的内容-DOM-（前提条件是同域，如果跨域顶多只能实现页面跳转）"><a href="#基本的特性：-能自由操作iframe和父框架的内容-DOM-（前提条件是同域，如果跨域顶多只能实现页面跳转）" class="headerlink" title="基本的特性： 能自由操作iframe和父框架的内容(DOM). （前提条件是同域，如果跨域顶多只能实现页面跳转）"></a>基本的特性： 能自由操作iframe和父框架的内容(DOM). （前提条件是同域，如果跨域顶多只能实现页面跳转）</h4><blockquote><p>那什么是同域/ 什么是跨域呢?</p></blockquote><p>就是判断你的url首部是否一样，例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A:&lt;iframe id="mainIframe" name="mainIframe" src="/main.html" frameborder="0" scrolling="auto" &gt;&lt;/iframe&gt;</span><br><span class="line"></span><br><span class="line">B:&lt;iframe id="mainIframe" name="mainIframe" src="http://www.baidu.com" frameborder="0" scrolling="auto" &gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure><p></p><p>使用A时，因为同域，父页面可以对子页面进行改写,反之亦然。<br>使用B时，不同域，父页面没有权限改动子页面,但可以实现页面的跳转<br>这里，我们先从简单的开始，当主页面和iframe同域时，我们可以做些什么。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">"iframe1"</span>);</span><br><span class="line"><span class="keyword">var</span> iwindow = iframe.contentWindow;</span><br><span class="line"><span class="keyword">var</span> idoc = iwindow.document;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"window"</span>,iwindow);<span class="comment">//获取iframe的window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"document"</span>,idoc);  <span class="comment">//获取iframe的document</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"html"</span>,idoc.documentElement);<span class="comment">//获取iframe的html</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"head"</span>,idoc.head);  <span class="comment">//获取head</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"body"</span>,idoc.body);  <span class="comment">//获取body</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>另外一种简单的方法是根据name来获取<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;iframe src =&quot;/index.html&quot; id=&quot;ifr1&quot; name=&quot;ifr1&quot; scrolling=&quot;yes&quot;&gt;</span><br><span class="line">  &lt;p&gt;Your browser does not support iframes.&lt;/p&gt;</span><br><span class="line">&lt;/iframe&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    console.log(window.frames[&apos;ifr1&apos;].window);</span><br><span class="line">console.dir(document.getElementById(&quot;ifr1&quot;).contentWindow);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><h3 id="在iframe中获取父级内容"><a href="#在iframe中获取父级内容" class="headerlink" title="在iframe中获取父级内容"></a>在iframe中获取父级内容</h3><blockquote><p>同理，在同域下，父页面可以获取子iframe的内容，那么子iframe同样也能操作父页面内容。在iframe中，可以通过在window上挂载的几个API进行获取. 获取了之后，我们就可以进行相关操作了。</p></blockquote><h3 id="iframe的轮询"><a href="#iframe的轮询" class="headerlink" title="iframe的轮询"></a>iframe的轮询</h3><p>话说在很久很久以前，我们实现异步发送请求是使用iframe实现的~!<br>那时候为了不跳转页面，提交表单时是使用iframe提交的。现在，前端发展很快，websocket,SSE,ajax等的出现，颠覆了iframe, 现在基本上只能活在IE8,9的浏览器内了。</p><h4 id="iframe长轮询"><a href="#iframe长轮询" class="headerlink" title="iframe长轮询"></a>iframe长轮询</h4><blockquote><p>如果写过ajax的童鞋，应该知道，长轮询就是在ajax的readyState = 4的时，再次执行原函数即可。 这里使用iframe也是一样，异步创建iframe，然后reload, 和后台协商好, 看后台哥哥们将返回的信息放在,然后获取里面信息即可. 这里是直接放在body里.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeCon = docuemnt.querySelector(<span class="string">'#container'</span>),</span><br><span class="line">       text; <span class="comment">//传递的信息</span></span><br><span class="line">   <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>),</span><br><span class="line">       iframe.id = <span class="string">"frame"</span>,</span><br><span class="line">       iframe.style = <span class="string">"display:none;"</span>,</span><br><span class="line">       iframe.name=<span class="string">"polling"</span>,</span><br><span class="line">       iframe.src=<span class="string">"target.html"</span>;</span><br><span class="line">   iframeCon.appendChild(iframe);</span><br><span class="line">   iframe.onload= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="keyword">var</span> iloc = iframe.contentWindow.location,</span><br><span class="line">           idoc  = iframe.contentDocument;</span><br><span class="line">       setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">           text = idoc.getElementsByTagName(<span class="string">'body'</span>)[<span class="number">0</span>].textContent;</span><br><span class="line">           <span class="built_in">console</span>.log(text);</span><br><span class="line">           iloc.reload(); <span class="comment">//刷新页面,再次获取信息，并且会触发onload函数</span></span><br><span class="line">       &#125;,<span class="number">2000</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>还有一些应用还有待去结合业务场景敲实例，未完待续···</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/svg动画/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/svg动画/" itemprop="url">svg动画</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-28T10:17:31+08:00">2018-10-28</time></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="CSS3-动画已经很强大，但是有些时候像是用一些灵活简单的效果。使用css的话代码并不是很精简，处理较为复杂。配合-SVG的话，可以让-Web-动效有更多的可能性。"><a href="#CSS3-动画已经很强大，但是有些时候像是用一些灵活简单的效果。使用css的话代码并不是很精简，处理较为复杂。配合-SVG的话，可以让-Web-动效有更多的可能性。" class="headerlink" title="CSS3 动画已经很强大，但是有些时候像是用一些灵活简单的效果。使用css的话代码并不是很精简，处理较为复杂。配合 SVG的话，可以让 Web 动效有更多的可能性。"></a>CSS3 动画已经很强大，但是有些时候像是用一些灵活简单的效果。使用css的话代码并不是很精简，处理较为复杂。配合 SVG的话，可以让 Web 动效有更多的可能性。</h4><blockquote><p>实现一个购物袋的 loading 动效</p></blockquote><p>以一个购物袋的 loading 动效为示例，一起来熟悉上手 SVG 动画。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b818208704654?w=301&amp;h=233&amp;f=gif&amp;s=60669" alt=""><br>其中旋转通过 CSS 来完成，但是旋转之后圆弧缩短变成笑脸的嘴巴需要借助 SVG 来实现。</p><h3 id="步骤一：-声明-SVG-视窗"><a href="#步骤一：-声明-SVG-视窗" class="headerlink" title="步骤一： 声明 SVG 视窗"></a>步骤一： 声明 SVG 视窗</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;svg width=<span class="string">"100"</span> height=“<span class="number">100</span>”&gt;&lt;/svg&gt;</span><br></pre></td></tr></table></figure><p>指定一个宽高都为 100 像素的区域，width=”100” 和 width=”100px” 是等价的，当然也可以使用其他的合法单位，例如 cm、mm、em 等。</p><p>阅读器会设置一个默认的坐标系统，见下图：左上角为原点，其中水平（x）坐标向右递增，垂直（y）坐标向下递增。在没有指定的情况下，所有数值的默认单位都是像素。如下图</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b81b8a025179f?w=359&amp;h=276&amp;f=png&amp;s=1668" alt=""></p><h3 id="步骤二：-绘制购物袋"><a href="#步骤二：-绘制购物袋" class="headerlink" title="步骤二： 绘制购物袋"></a>步骤二： 绘制购物袋</h3><blockquote><p>购物袋由两个部分组成，先画下面的主体：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=<span class="string">"M 20 40 L 80 40 L 80 90 A 10 10 90 0 1 70 100 L 30 100 A 10 10 90 0 1 20 90"</span> style=<span class="string">"fill: #e9e8ee;"</span> /&gt;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>任何形状都可以使用路径元素画出，描述轮廓的数据放在它的 d 属性中。</p><p>1.样式中的 fill 用来设置填充色</p><p>2.路径数据由命令和坐标构成<br>| 指令 | 说明 |<br>| :——| :—— |<br>| M 20 40 | 表示移动画笔到 (20,40) |<br>| L 80 40 | 表示绘制一条线到 (80, 40) |<br>| A 10 10 90 0 1 70 100 | 绘制一个椭圆弧 |<br>圆弧命令以字母 A 开始，后面紧跟着 7 个参数，这 7 个参数分别用来表示：<br>1.椭圆的 x 半径和 y 半径<br>2.椭圆的 x 轴旋转角度<br>3.圆弧的角度小于 180 度，为 0；大于或等于 180 度，则为 1<br>4.以负角度绘制为 0，否则为 1<br>5.<br><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b8219de1b73cb?w=335&amp;h=289&amp;f=png&amp;s=1892" alt="">终点的x、y坐标</p><blockquote><p>接下来绘制购物袋上面的部分：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path d=<span class="string">"M 35 40 A 15 15 180 1 1 65 40"</span> style=<span class="string">"fill: none; stroke: #e9e8ee; stroke-width: 5;” /&gt;</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p>上面的部分是一个半圆弧，同样用路径来画出，当然也可以使用基础形状来完成。</p><p>样式中的 stoke 和 stroke-width 分别用来设置描边色和描边的宽度。<br><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b822daa6efeb5?w=305&amp;h=286&amp;f=png&amp;s=2281" alt=""></p><h3 id="步骤三：-绘制眼睛"><a href="#步骤三：-绘制眼睛" class="headerlink" title="步骤三： 绘制眼睛"></a>步骤三： 绘制眼睛</h3><p>使用基础形状，画两个小圆点。四个属性分别是位置坐标、半径和填充颜色。<br><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b824974438924?w=297&amp;h=287&amp;f=png&amp;s=2359" alt=""><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle cx=“40" cy="60" r="2.5" style="fill: #fff;" /&gt;</span><br><span class="line">&lt;circle cx=<span class="string">"60"</span> cy=<span class="string">"60"</span> r=<span class="string">"2.5"</span> style=<span class="string">"fill: #fff;"</span> /&gt;</span><br></pre></td></tr></table></figure><p></p><h3 id="步骤四：-绘制嘴巴"><a href="#步骤四：-绘制嘴巴" class="headerlink" title="步骤四： 绘制嘴巴"></a>步骤四： 绘制嘴巴</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle cx=<span class="string">"50"</span> cy=<span class="string">"70"</span> r=<span class="string">"15"</span> style=<span class="string">"fill: none; stroke: #fff; stroke-width: 5; stroke-linecap: round;transform: rotate(280deg); transform-origin: 50% 50%; stroke-dashoffset: -23; stroke-dasharray: 42, 95;”&gt;</span></span><br></pre></td></tr></table></figure><p>嘴巴是一段圆弧，我绘制了一个圆，然后描边了其中的一段，并且做了一个旋转，来让它的角度处于正确的位置。</p><blockquote><p>1.stroke-linecap：用来定义开放路径的终结,可选 round|butt|square<br>2.stroke-dasharray：用来创建虚线<br>3.stroke-dashoffset：设置虚线位置的起始偏移值，在下一个步骤里，它会和stroke-dasharray 一起用来实现动效…</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b82701c0bb7cc?w=314&amp;h=285&amp;f=png&amp;s=2828" alt=""></p><h3 id="步骤五：-给嘴巴部分添加动效"><a href="#步骤五：-给嘴巴部分添加动效" class="headerlink" title="步骤五： 给嘴巴部分添加动效"></a>步骤五： 给嘴巴部分添加动效</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mouth &#123;</span><br><span class="line"> <span class="number">0</span>% &#123;</span><br><span class="line">  transform: rotate(<span class="number">-80</span>deg);</span><br><span class="line">  stroke-dasharray: <span class="number">60</span>, <span class="number">95</span>;</span><br><span class="line">  stroke-dashoffset: <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="number">40</span>% &#123;</span><br><span class="line">  transform: rotate(<span class="number">280</span>deg);</span><br><span class="line">  stroke-dasharray: <span class="number">60</span>, <span class="number">95</span>;</span><br><span class="line">  stroke-dashoffset: <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="number">70</span>%, <span class="number">100</span>% &#123;</span><br><span class="line">  transform: rotate(<span class="number">280</span>deg);</span><br><span class="line">  stroke-dashoffset: <span class="number">-23</span>;</span><br><span class="line">  stroke-dasharray: <span class="number">42</span>, <span class="number">95</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动画分为两个部分：</p><p>1.圆弧旋转<br>2.旋转之后缩短变形<br>在一个循环里，最后留有 30% 的时间保持一个停留状态。</p><p><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b8292f60d930e?w=354&amp;h=282&amp;f=gif&amp;s=76664" alt=""></p><h3 id="给眼睛添加动画"><a href="#给眼睛添加动画" class="headerlink" title="给眼睛添加动画"></a>给眼睛添加动画</h3><p>两只眼睛都是沿着圆弧运动 ，例如左眼，首先用一个路径来规定它的运动轨迹：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;path id=<span class="string">"eyeright"</span> d=<span class="string">"M 40 60 A 15 15 180 0 1 60 60"</span> style=<span class="string">"fill: none; stroke-width: 0;"</span> /&gt;</span><br></pre></td></tr></table></figure><p>然后使用 animateMotion 来设置动画：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;circle <span class="class"><span class="keyword">class</span></span>=<span class="string">"eye"</span> cx=<span class="string">""</span> cy=<span class="string">""</span> r=<span class="string">"2.5"</span> style=<span class="string">"fill: #fff;"</span>&gt;</span><br><span class="line"> &lt;animateMotion</span><br><span class="line">  dur=<span class="string">"0.8s"</span></span><br><span class="line">  repeatCount=<span class="string">"indefinite"</span></span><br><span class="line">  keyPoints=<span class="string">"0;0;1;1"</span></span><br><span class="line">  keyTimes=<span class="string">"0;0.3;0.9;1"</span></span><br><span class="line">  calcMode=<span class="string">"linear"</span>&gt;</span><br><span class="line">  &lt;mpath xlink:href=<span class="string">"#eyeleft"</span>/&gt;</span><br><span class="line"> &lt;<span class="regexp">/animateMotion&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>circle&gt;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>1.dur：动画的时间<br>2.repeatCount：重复次数<br>3.keyPoints：运动路径的关键点<br>4.timePoints：时间的关键点<br>5.calcMode：控制动画的运动速率的变化，discrete | linear | paced|spline 四个属性可选<br>6.mpath：指定一个外部定义的路径</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b82c15ea283b9?w=354&amp;h=282&amp;f=gif&amp;s=62795" alt=""></p><h3 id="步骤7"><a href="#步骤7" class="headerlink" title="步骤7"></a>步骤7</h3><p>将不同部位的动画组合到一起</p><blockquote><p>眼睛的动画是从嘴巴旋转完成开始，到嘴巴变形完成结束，因此和嘴巴的动画一样，设置了四个对应的关键时间点。<br>为了让衔接更顺畅，眼睛的动画开始比嘴巴变形开始稍微提前了一点点。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/10/28/166b82d9e0d442e4?w=354&amp;h=282&amp;f=gif&amp;s=101961" alt=""></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>SVG 在网页中的角色更像是类似图片一样的媒体对象，其动画也常常和 CSS 有关联，除了微软系的浏览器不支持之外，其兼容性还是相当可观的。在平时工作过程中，矢量图标的动画、轨迹动画特别适合使用 SVG 来实现。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/浏览器页面渲染机制/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/浏览器页面渲染机制/" itemprop="url">浏览器页面渲染机制</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-22T12:34:56+08:00">2018-10-22</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="分享目的：-解释浏览器如何将-HTML、CSS-和-JavaScript-转换为我们可以与之交互的网站，了解这个过程，可以帮助我们优化-Web-应用程序，从而获得更快的速度和更好的性能。"><a href="#分享目的：-解释浏览器如何将-HTML、CSS-和-JavaScript-转换为我们可以与之交互的网站，了解这个过程，可以帮助我们优化-Web-应用程序，从而获得更快的速度和更好的性能。" class="headerlink" title="分享目的： 解释浏览器如何将 HTML、CSS 和 JavaScript 转换为我们可以与之交互的网站，了解这个过程，可以帮助我们优化 Web 应用程序，从而获得更快的速度和更好的性能。"></a>分享目的： 解释浏览器如何将 HTML、CSS 和 JavaScript 转换为我们可以与之交互的网站，了解这个过程，可以帮助我们优化 Web 应用程序，从而获得更快的速度和更好的性能。</h3><h4 id="问题：-浏览器如何渲染网站？-接下来会解构这个过程，但是首先，有必要了解一些基础概念"><a href="#问题：-浏览器如何渲染网站？-接下来会解构这个过程，但是首先，有必要了解一些基础概念" class="headerlink" title="问题： 浏览器如何渲染网站？ (接下来会解构这个过程，但是首先，有必要了解一些基础概念)"></a>问题： 浏览器如何渲染网站？ (接下来会解构这个过程，但是首先，有必要了解一些基础概念)</h4><blockquote><p>Web 浏览器是一种软件，它从远程服务器（或者本地磁盘）加载文件并将其显示——使用户可以与之交互。浏览器中有一个软件叫浏览器引擎。在不同的浏览器中，浏览器的某个部分会根据它接收到的文件确定显示什么，这就是所谓的浏览器引擎。浏览器引擎是每一种主流浏览器的核心软件组件，不同的浏览器开发商用不同的名字来称呼他们的引擎。</p></blockquote><h3 id="1-html解析"><a href="#1-html解析" class="headerlink" title="1. html解析"></a>1. html解析</h3><ul><li>接收信息<br>数据是以“数据包”的形式通过互联网发送，而数据包以字节为单位。当你编写一些 HTML、CSS 和 JS，并试图在浏览器中打开 HTML 文件时，浏览器会从你的硬盘（或网络）中读取 HTML 的原始字节。</li><li>计算机接收到字节数据<br>浏览器读取的是原始数据字节，而不是你编写的代码的实际字符。浏览器读取的是原始数据字节，而不是你编写的代码的实际字符。<ul><li>从 HTML 的原始字节到 DOM，浏览器对象需要处理的是文档对象模型（DOM）对象。那么，DOM 对象是从何而来的呢？首先，将原始数据字节转换为字符。（Bytes =&gt; haracters）</li><li>从字节到字符<br>这一点，你可以通过你所编写的代码的字符看到。这种转换是基于 HTML 文件的字符编码完成的。至此，浏览器已经从原始数据字节转换为文件中的实际字符。但这不是最终的结果。这些字符会被进一步解析为一些称为“标记（token）”的东西。（Bytes =&gt; haracters =&gt; Tokens···）</li><li>从字符到标记<br>那么，这些标记是什么？文本文件中的一堆字符对浏览器引擎而言没什么用处。如果没有这个标记化过程，那么这一堆堆字符只会生成一系列毫无意义的文本，即 HTML 代码——不会生成一个真正的网站。<br>当你保存一个扩展名为.html 的文件时，就向浏览器引擎发出了把文件解析为 HTML 文档的信号。浏览器“解释”这个文件的方式是首先解析它。在解析过程中，特别是在标记化过程中，浏览器会解析 HTML 文件中的每个开始和结束“标签（tag）”。解析器可以识别尖括号中的每个字符串，如“&lt; html&gt;”、“&lt; p&gt;”<blockquote><p>但标记还不是最终的结果。标记化完成后，接下来，标记将被转换为节点。你可以将节点看作是具有特定属性的不同对象。实际上，更好的解释是，将节点看作是文档对象树中的独立实体。但节点仍然不是最终结果。<br>现在，让我们看一下最后一点。在创建好之后，这些节点将被链接到称为DOM 的树数据结构中。DOM 建立起了父子关系、相邻兄弟关系等。在这个 DOM 对象中，每个节点之间都建立了关系。现在，这是我们可以使用的东西了。</p></blockquote></li></ul></li><li>标记<br>但标记还不是最终的结果。标记化完成后，接下来，标记将被转换为节点。你可以将节点看作是具有特定属性的不同对象。实际上，更好的解释是，将节点看作是文档对象树中的独立实体。但节点仍然不是最终结果。</li><li>DOM (Bytes =&gt; haracters =&gt; Tokens =&gt; Node =&gt; DOM)<br>让我们看一下最后一点。在创建好之后，这些节点将被链接到称为 DOM 的树数据结构中。DOM 建立起了父子关系、相邻兄弟关系等。在这个 DOM 对象中，每个节点之间都建立了关系。这个时候，是浏览器需要的东西了。</li></ul><hr><h3 id="2-css解析"><a href="#2-css解析" class="headerlink" title="2.css解析"></a>2.css解析</h3><p>这个是我们很常见的写法<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span>  href=<span class="string">"test.css"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>当浏览器接收到原始数据字节并启动 DOM 构建过程时，它还会发出请求来获取链接的 test.css 样式表。当浏览器开始解析 HTML 时，在找到 css 文件的链接标签的同时，它会发出请求来获取它。可能你已经猜到，浏览器还是接收 CSS 数据的原始字节，从互联网或是本地磁盘。</p></blockquote><h4 id="浏览器如何处理这些-CSS-数据的原始字节？"><a href="#浏览器如何处理这些-CSS-数据的原始字节？" class="headerlink" title="浏览器如何处理这些 CSS 数据的原始字节？"></a>浏览器如何处理这些 CSS 数据的原始字节？</h4><blockquote><p>当浏览器接收到 CSS 的原始字节时，会启动一个和处理 HTML 原始字节类似的过程。就是说，原始数据字节被转换成字符，然后标记，然后形成节点，最后形成树结构。<br>什么是树结构？大多数人都知道 DOM 这个词。同样，也有一种 CSS 树结构，，浏览器不能使用 HTML 或 CSS 的原始字节。必须将其转换成它能识别的形式，也就是这些树形结构。</p></blockquote><h4 id="DOM-CSSOM-渲染树"><a href="#DOM-CSSOM-渲染树" class="headerlink" title="DOM + CSSOM = 渲染树"></a>DOM + CSSOM = 渲染树</h4><blockquote><p>渲染树包含页面上所有关于可见 DOM 内容的信息以及不同节点所需的所有 CSSOM 信息。注意，如果一个元素被 CSS 隐藏，例如使用 display; none，那么节点就不会包含在渲染树中。隐藏元素会出现在 DOM 中，但不会出现在渲染树中。这是因为渲染树结合了来自 DOM 和 CSSOM 的信息，所以它知道不能把隐藏元素包含在树中。</p></blockquote><h4 id="元素展示"><a href="#元素展示" class="headerlink" title="元素展示"></a>元素展示</h4><blockquote><p>我们已经得到了在屏幕上显示元素所需的所有信息。我们只要把它展示给用户。这就是这个阶段的全部工作。有了元素内容（DOM）、样式（CSSOM）和计算得出的元素的精确布局信息，浏览器现在就可以将节点逐个“绘制”到屏幕上了。元素可以呈现在屏幕上了！</p></blockquote><hr><h3 id="渲染阻塞资源"><a href="#渲染阻塞资源" class="headerlink" title="渲染阻塞资源"></a>渲染阻塞资源</h3><blockquote><p>通俗的解释为有东西阻止了屏幕上节点的实际绘制,在成功绘制之前，必须构造 DOM 和 CSSOM，因此，HTML 和 CSS 都是渲染阻塞资源。</p></blockquote><ul><li>JavaScript 如何执行？<br>一个常用的 Web 应用程序肯定会使用一些 JavaScript。这是一定的。JavaScript 的“问题”在于你可以使用 JavaScript 修改页面的内容和样式。通过这种方式，你可以从 DOM 树中删除元素和添加元素，还可以通过 JavaScript 修改元素的 CSSOM 属性。这很方便，但是同时也带来了弊端</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;title&gt;testRander&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;link rel="stylesheet" href="style.css"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p&gt;浏览器页面渲染机制&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;img src="http:/</span><span class="regexp">/spage.haimati.cn/</span>activityImage/newplan.jpg<span class="string">"&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>这是一个非常常见的文档。样式表 style.css简单定义样式：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  font-size: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  background-color: antiquewhite;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/10/22/16698fb2a401ab9d?w=1922&amp;h=1030&amp;f=png&amp;s=299846" alt=""></p><p>一段简单的文本和图像呈现在屏幕上。</p><p>根据前面的解释，浏览器从磁盘（或网络）读取 HTML 文件的原始字节并将其转换为字符。字符被进一步解析为标记。当解析器遇到&lt; link rel=”stylesheet” href=”style.css”&gt;时，就会请求获取 CSS 文件 style.css。DOM 构造继续进行，当 CSS 文件返回一些内容后，CSSOM 构造就开始了。</p><ul><li>引入 JavaScript<br>每当浏览器遇到脚本标签时，DOM 构造就会暂停！整个 DOM 构建过程都将停止，直到脚本执行完成。JavaScript 可以同时修改 DOM 和 CSSOM。由于浏览器不确定特定的 JavaScript 会做什么，所以它采取的预防措施是停止整个 DOM 构造。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;title&gt;testRander&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;link rel="stylesheet" href="style.css"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;p id=<span class="string">"title"</span>&gt;浏览器页面渲染机制&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;img src="http:/</span><span class="regexp">/spage.haimati.cn/</span>activityImage/newplan.jpg<span class="string">"&gt;</span></span><br><span class="line"><span class="string">  &lt;script&gt;</span></span><br><span class="line"><span class="string">      let title = document.getElementById("</span>title<span class="string">");</span></span><br><span class="line"><span class="string">      console.log("</span>title is: <span class="string">", title);</span></span><br><span class="line"><span class="string">  &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/10/22/166990b96268546b?w=1944&amp;h=1310&amp;f=png&amp;s=384720" alt=""><br>当把js放到元素之前的话<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> &lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;title&gt;testRander&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;link rel="stylesheet" href="style.css"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        <span class="keyword">let</span> title = <span class="built_in">document</span>.getElementById(<span class="string">"title"</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"title is: "</span>, title);</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">  &lt;p id="title"&gt;浏览器页面渲染机制&lt;/</span>p&gt;</span><br><span class="line">  &lt;img src=<span class="string">"http://spage.haimati.cn/activityImage/newplan.jpg"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure><p></p><p><img src="https://user-gold-cdn.xitu.io/2018/10/22/166990fe47d9a627?w=1958&amp;h=1292&amp;f=png&amp;s=349758" alt=""></p><blockquote><p>当脚本试图访问一个 id 为 header 的 DOM 节点时，由于 DOM 还没有完成对文档的解析，所以它还不存在。这把我们带到了另一个重要的问题。脚本的位置很重要。</p></blockquote><p>在默认情况下，每个脚本都是一个解析器阻断器！DOM 的构建总是会被打断。不过，有一种方法可以改变这种默认行为。如果将 async 关键字添加到脚本标签中，那么 DOM 构造就不会停止。DOM 构造将继续，脚本将在下载完成并准备就绪后执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">  &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">  &lt;title&gt;testRander&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;link rel="stylesheet" href="style.css"&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;script src=<span class="string">"test.js"</span> <span class="keyword">async</span>&gt;&lt;/script&gt;</span><br><span class="line">  &lt;p id=<span class="string">"title"</span>&gt;浏览器页面渲染机制&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;img src="http:/</span><span class="regexp">/spage.haimati.cn/</span>activityImage/newplan.jpg<span class="string">"&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>把js放入test.js中进行引入<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> title = <span class="built_in">document</span>.getElementById(<span class="string">"title"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"title is: "</span>, title);</span><br></pre></td></tr></table></figure><p></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/10/22/166991a0ff1ff46f?w=1982&amp;h=1016&amp;f=png&amp;s=389832" alt=""></p><blockquote><p>这样DOM的构建就不会停止，脚本在构造完成后执行。</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/Promise的作用以及基本使用/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/Promise的作用以及基本使用/" itemprop="url">Promise的作用以及基本使用</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-16T02:28:06+08:00">2018-10-16</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="Promise的作用以及基本使用"><a href="#Promise的作用以及基本使用" class="headerlink" title="Promise的作用以及基本使用"></a>Promise的作用以及基本使用</h3><h4 id="关于Promise的概念，在实际使用之前对其的理解一直比较模糊，只是停留在一些文档上的描述。在使用中其实可以根据其特性进行一些更佳的实践。在这里简单介绍一下其作用以及基础用法。"><a href="#关于Promise的概念，在实际使用之前对其的理解一直比较模糊，只是停留在一些文档上的描述。在使用中其实可以根据其特性进行一些更佳的实践。在这里简单介绍一下其作用以及基础用法。" class="headerlink" title="关于Promise的概念，在实际使用之前对其的理解一直比较模糊，只是停留在一些文档上的描述。在使用中其实可以根据其特性进行一些更佳的实践。在这里简单介绍一下其作用以及基础用法。"></a>关于Promise的概念，在实际使用之前对其的理解一直比较模糊，只是停留在一些文档上的描述。在使用中其实可以根据其特性进行一些更佳的实践。在这里简单介绍一下其作用以及基础用法。</h4><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><hr><p>Promise对象可以理解为一次执行的异步操作，使用promise对象之后可以使用一种链式调用的方式来组织代码；让代码更加的直观。也就是说，有了Promise对象，就可以将异步操作以同步的操作的流程表达出来，避免了层层嵌套的回调函数。总结一下就是可以将原先不可控的回调通过promise转为更加可控更清晰的方式表达，更加高效，更便于维护。</p><blockquote><p>示例：未使用promise，回调必须层层嵌套<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(url1, <span class="function"><span class="keyword">function</span>(<span class="params">data1</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// do something1...</span></span><br><span class="line">    $.ajax(url2, <span class="function"><span class="keyword">function</span>(<span class="params">data2</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// do something2...</span></span><br><span class="line">        $.ajax(url3, <span class="function"><span class="keyword">function</span>(<span class="params">data3</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// do something3...</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p></blockquote><p>如果有多个嵌套，导致代码不够直观，逻辑梳理上会更加的困难。并且这几个操作都是有执行的一个依赖关系，需要等待上一个请求完成才可以进行下一个请求，而这些本身就是异步，这样的等待是没有必要的。所以promise可以帮助我们解决这一部分痛点。</p><h4 id="了解一下Promise的特点"><a href="#了解一下Promise的特点" class="headerlink" title="了解一下Promise的特点"></a>了解一下Promise的特点</h4><p>1、对象的状态不受外界影响（Promise对象代表一个异步操作，有三种状态）。</p><ul><li>pending（执行中）</li><li>Resolved（成功，又称Fulfilled）</li><li>rejected（拒绝）</li></ul><p>其中pending为初始状态，fulfilled和rejected为结束状态（结束状态表示promise的生命周期已结束）。promise只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态.。</p><p>2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。</p><p>Promise对象的状态改变，只有两种可能：</p><ul><li>从Pending变为Resolved</li><li>从Pending变为Rejected<blockquote><p>只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果</p></blockquote></li></ul><p>3、Promise对象的缺点：</p><ul><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li><li>当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成。</li></ul><p>4、promise兼容性：除了IE这种古老的浏览器和一些低版本的安卓外，大部分的浏览器对于promise的兼容性还是很友好的，所以我们可以在谷歌的控制台直接测试我们的代码。</p><blockquote><p>接下来用一些例子来看看具体的使用方法</p></blockquote><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><hr><p>1、首先我们new一个Promise,将Promise实例化<br>2、然后在实例化的promise可以传两个参数，一个是成功之后的resolve，一个是失败之后的reject<br>3、Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="function"><span class="keyword">function</span>(<span class="params">isReady</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// do somthing, maybe async</span></span><br><span class="line">        <span class="keyword">if</span> (isReady)&#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(<span class="string">'成功执行'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> reject(<span class="string">'出错了'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</span></span><br><span class="line">promise(<span class="literal">true</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// success,这里是resolve的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(value);  <span class="comment">//hello world</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// failure，这里是reject的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><blockquote><p>上述代码是执行成功，返回成功执行,如果想测试一下失败后的返回值，可以把promise(true).then…这里改为 promise(false).then…在控制台试下</p></blockquote><h3 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h3><hr><p>Promise并不只是简化层层回调的写法，更重要的在于是通过传递状态的方式来使回调方式能够及时的调用，因此，相比于callback，它更灵活，更简单。下面我们来看看Promise的链式操作：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">makePromise1()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> makePromise2();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="keyword">return</span> makePromise3();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePromise1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步1'</span>);</span><br><span class="line">            resolve(<span class="string">'异步1参数'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePromise2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步2'</span>);</span><br><span class="line">            resolve(<span class="string">'异步2参数'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makePromise3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//异步操作</span></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'异步3'</span>);</span><br><span class="line">            resolve(<span class="string">'异步3参数'</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>上面的代码中，有三个异步操作，makePromise1,makePromise2,makePromise3。其中第二个和第三个依次执行，也就是上一个操作完成之后才可以进行。会相继的打印出异步1，异步1参数···</p></blockquote><h3 id="Promise的catch方法"><a href="#Promise的catch方法" class="headerlink" title="Promise的catch方法"></a>Promise的catch方法</h3><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="function"><span class="keyword">function</span>(<span class="params">isReady</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isReady)&#123;</span><br><span class="line">          <span class="keyword">return</span> resolve(<span class="string">'成功执行'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> reject(<span class="string">'失败'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">promise(<span class="literal">true</span>)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'resolved'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="built_in">console</span>.log(wawa); <span class="comment">//此处的wawa未定义</span></span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>catch 方法是 then(onFulfilled, onRejected) 方法当中 onRejected 函数的一个简单的写法，也就是说可以写成 then(fn).catch(fn),相当于 then(fn).then(null, fn)使用 catch 的写法比一般的写法更加清晰明确，其实可以类比成try/catch，这样，其中有报错的地方不会阻塞运行。比如定义了一个未定义wawa,正常来说它上面的代码也不会运行，因为被这个报错阻塞了，有了catch,它上面的代码可以正常运行下去</p></blockquote><h3 id="promise-all方法"><a href="#promise-all方法" class="headerlink" title="promise.all方法"></a>promise.all方法</h3><hr><blockquote><p>Promise.all 可以接收一个元素为 Promise 对象的数组作为参数，当这个数组里面所有的 Promise 对象都变为 resolve 时，该方法才会返回。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">"第一个promise"</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(<span class="string">"第二个promise"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// ["第一个promise", "第二个promise"]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>上面的代码中，all接收一个数组作为参数，p1,p2是并行执行的，等两个都执行完了，才会进入到then，all会把所有的结果放到一个数组中返回，所以我们打印出我们的结果为一个数组。值得注意的是，虽然p2的执行顺序比p1快，但是all会按照参数里面的数组顺序来返回结果。</p></blockquote><h3 id="promise-race方法"><a href="#promise-race方法" class="headerlink" title="promise.race方法"></a>promise.race方法</h3><hr><p>race的意思为赛跑，因此，promise.race也是传入一个数组，但是与promise.all不同的是，race只返回跑的快的值，也就是说result返回比较快执行的那个。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        resolve(<span class="string">"第一个promise"</span>);</span><br><span class="line">    &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">        resolve(<span class="string">"第二个promise"</span>);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 第二个promise</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p></p><blockquote><p>在这边可以看到，传的值中，只有p2的返回了，但是p1没有停止，依然有执行。race的应用场景为，比如我们可以设置为网路请求超时。写两个promise，如果在一定的时间内如果成功的那个我们没有执行到，我们就执行失败的那个</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/正则表达式/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/正则表达式/" itemprop="url">正则表达式</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-15T00:00:00+08:00">2018-09-15</time></span></div></header><div class="post-body" itemprop="articleBody"><h4 id="正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。"><a href="#正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。" class="headerlink" title="正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。"></a>正则表达式在平时工作中非常常见，工作中用到的大部分正则都是去网上搜索得来的，再复杂一点看着文档费时费力的拼凑一下。所以觉得很有必要对一些常用的正则内容进行一个归纳和总结。</h4><blockquote><p>概念： Regular Expression使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。说简单了就是按照某种规则去匹配符合条件的字符串。</p></blockquote><h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><hr><p>javaScript中通过内置对象 RegExp 支持正则表达式，有两种方法实例化 RegExp 对象：</p><p>1.字面量<br>2.构造函数</p><h3 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h3><p>假设你需要把一句英文里面的小写is匹配成大写的 IS，可以这样做：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/is/</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'He is a boy, This is a dog. Where is she?'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'IS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//He IS a boy, This is a dog. Where is she?</span></span><br></pre></td></tr></table></figure><p></p><p>这样就把第一个英文单词’is’替换成了’IS’，假如你想把该句中所有的单词’is’都替换成’IS’,应该这样写：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/is/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'He is a boy, This is a dog. Where is she?'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'IS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//He IS a boy, ThIS IS a dog. Where IS she?</span></span><br></pre></td></tr></table></figure><p></p><p>在正则的末尾加上’g’就好，’g’表示global，是全局匹配的意思。’g’是正则表达式的一个修饰符，修饰符有:</p><ul><li>‘g’: global 全文搜索，不添加的话，搜索到第一个停止</li><li>‘i’: ignore case 忽略大小写，默认大小写敏感</li><li>‘m’: multiple 多行搜索，检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用</li></ul><p>但是这样的话也改变了this中is的大小写，这显然不是我们想要的，所以这个时候可以这样做<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\bis\b/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'He is a boy, This is a dog. Where is she?'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'IS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//He IS a boy, This IS a dog. Where IS she?</span></span><br></pre></td></tr></table></figure><p></p><p>‘\b’:匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。这里的正则在’is’的前后都有’\b’，这样就只能匹配单词’is’了。</p><h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h3><p>倘若你需要使用构造函数的方式实例化正则，则上面的字面量形式可以改成这样：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\bis\\b'</span>,<span class="string">'g'</span>);</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'He is a boy, This is a dog. Where is she?'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'IS'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//He IS a boy, This IS a dog. Where IS she?</span></span><br></pre></td></tr></table></figure><p></p><p>用这种方式就不需要’/‘符号开始和结尾以表示是正则了。但是里面的’\’等特殊字符需要用’\’转义。</p><p>“\”:将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\n”匹配一个换行符。串行“\ \”匹配“\”而“\ (”则匹配“(”。</p><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><hr><p>正则表达式由两种基本字符类型组成：</p><ul><li>原义文本字符，即代表它原本含义的字符</li><li>元字符，元字符是在正则表达式中有特殊含义的非字母字符，例如上文提到的’\b’，表示匹配单词边界，并不是匹配’\b’，在正则中主要存在这些特殊字符：*,+,?,$,^,.,|,\,(,),{,},[,]</li></ul><h3 id="字符类（字符集合）"><a href="#字符类（字符集合）" class="headerlink" title="字符类（字符集合）"></a>字符类（字符集合）</h3><hr><p>一般情况下，正则表达式一个字符对应字符串一个字符</p><blockquote><p>思考： var text = ‘a1b2c3d4’; 把英文字母都换成X</p></blockquote><p>但是更多的时候，我们匹配的并不是某个字符，而是符合一系列特征的字符串。这时候，我们就可以使用元字符’[]’来构建一个简单的类，所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符，例如：表达式’[abc]’把字符a或b或c归为一类，表达式可以匹配这样的字符。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[abc]/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'a1b2c3d4'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'X'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//X1X2X3d4</span></span><br></pre></td></tr></table></figure><p></p><h4 id="字符类取反"><a href="#字符类取反" class="headerlink" title="字符类取反"></a>字符类取反</h4><p>使用元字符’^’创建 反向类/负向类。反向类的意思是不属于类的内容，表达式’[^abc]’表示不是字符a或b或c的内容,例如：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[^abc]/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'a1b2c3d4'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'X'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//aXbXcXXX</span></span><br></pre></td></tr></table></figure><p></p><h3 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h3><hr><blockquote><p>思考： var text = ‘a1b2c3d4z9’; 把英文字母都换成Q</p></blockquote><p>倘若我们需要用字符类匹配数字，按照前面的匹配方式，书写可能会很麻烦，需要这样：’[0123456789]’，对于 a 到 z 的字符更是如此。</p><p>为此，正则表达式给我们提供了范围类，我们可以使用[a-z]来连接两个字符，表示从a到z的任意字符，这是一个闭区间，包含 a 和 z 本身。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-z]/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'a1b2c3d4z9'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'Q'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//Q1Q2Q3Q4Q9</span></span><br></pre></td></tr></table></figure><p></p><p>可以发现，这样就方便了许多。此外，在’[]’组成的类的内部是可以连写的[a-zA-Z]，这样就形成了大写字母小写字母完全匹配:<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[a-zA-Z]/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'a1b2c3d4z9ASDFHDFH'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'Q'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//Q1Q2Q3Q4Q9QQQQQQQQ</span></span><br></pre></td></tr></table></figure><p></p><h3 id="预定义类及边界"><a href="#预定义类及边界" class="headerlink" title="预定义类及边界"></a>预定义类及边界</h3><hr><h4 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h4><blockquote><p>思考： 匹配一个 ab+数字+任意字符 的字符串：</p></blockquote><p>正则表达式提供预预定义类来匹配常见的字符类，让我们书写更方便。</p><table><thead><tr><th>字符</th><th>等价类</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>[^\r\n]</td><td>除了回车符和换行符之外的所有字符</td></tr><tr><td>\d</td><td>[0-9]</td><td>数字字符</td></tr><tr><td>\D</td><td>[^0-9]</td><td>非数字字符</td></tr><tr><td>\s</td><td>[\t\n\x0B\f\r]</td><td>空白符</td></tr><tr><td>\S</td><td>[^\t\n\x0B\f\r]</td><td>非空白符</td></tr><tr><td>\w</td><td>[a-zA-Z_0-9]</td><td>单词字符（字母、数字、下划线）</td></tr><tr><td>\w</td><td>[a-zA-Z_0-9]</td><td>单词字符（字母、数字、下划线）</td></tr><tr><td>\W</td><td>[^a-zA-Z_0-9]</td><td>非单词字符</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/ab\d./</span>; <span class="comment">//之前我们可能会这样写：ab[0-9][^\r\n]</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'absdlkjflab91323'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'AAAA'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">//absdlkjflAAAA323</span></span><br></pre></td></tr></table></figure><h4 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h4><blockquote><p>思考： var text = ‘He is a boy, This is a dog. Where is she?’; 我们在第一个例子中用到过’\b’单词边界，这里我们做一个跟上面第一个例子相反的，只把’This’中的’is’替换为’IS’</p></blockquote><p>除了预定义类，正则表达式还提供了几个常用的边界字符。</p><table><thead><tr><th>字符</th><th>等价类</th></tr></thead><tbody><tr><td>^</td><td>以xxx开始</td></tr><tr><td>$</td><td>以xxx结束</td></tr><tr><td>\b</td><td>单词边界</td></tr><tr><td>\B</td><td>非单词边界</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\Bis\b/g;</span><br><span class="line">var text = &apos;He is a boy, This is a dog. Where is she?&apos;;</span><br><span class="line">var result = text.replace(reg,&apos;IS&apos;);</span><br><span class="line">console.log(result) //He is a boy, ThIS is a dog. Where is she?</span><br></pre></td></tr></table></figure><p>在类’[]’中’^’表示取反，但是不在类中的时候’^’表示以xxx开始，’$’表示以xxx结束，这两个边界字符一般放在正则的开始和结束位置。</p><h3 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h3><hr><p>倘若我们希望匹配一个连续出现20次的数字的字符串，通过我们之前学习的知识，我们可能会写出连续20个’\d’。假如20次你还可以接受，那100次，1000次，甚至更多次，你怎么办？<br>为了解决这个问题，正则表达式引入了量词的概念，下面是一些量词和他们的含义：</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>？</td><td>出现零次或一次（最多出现一次）</td></tr><tr><td>+</td><td>出现一次或者多次（至少出现一次</td></tr><tr><td>*</td><td>出现零次或者多次（任意次）</td></tr><tr><td>{n}</td><td>出现n次</td></tr><tr><td>{n,m}</td><td>出现n到m次</td></tr><tr><td>{n,}</td><td>至少出现n次</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\d&#123;4&#125;[/-]\d&#123;2&#125;[/-]\d&#123;2&#125;/g;</span><br><span class="line">var text = &apos;2018-02-23，2018/02/24，2018~02/25&apos;;</span><br><span class="line">var result = text.replace(reg,&apos;匹配正确日期格式&apos;);</span><br><span class="line">console.log(result);//匹配正确日期格式，匹配正确的日期格式，2018~02/25</span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><hr><blockquote><p>思考： var text = ‘ByronByronByronnn’;将单词Byron替换为数字0</p></blockquote><p>匹配字符串 Byron 连续出现3次的场景，根据前面所了解的，我们可能会这样写：Byron{3}。<br>但是这样是错误的，试试你会发现只有Byronnn才能匹配成功，即最后的n重复了3次，并不能匹配整个单词重复三次的情况：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var reg = /Byron&#123;3&#125;/g;</span><br><span class="line">var text = &apos;ByronByronByronnn&apos;;</span><br><span class="line">var result = text.replace(reg,&apos;0&apos;);</span><br><span class="line">console.log(result);//ByronByron0</span><br></pre></td></tr></table></figure><p></p><p>那么，我们要怎么匹配Byron连续出现3次的情况呢，这时候，正则表达式的分组’()’就帮我们解决了这个问题：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(Byron)&#123;3&#125;/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'ByronByronByronnn'</span>;</span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//0nn</span></span><br></pre></td></tr></table></figure><p></p><h4 id="或"><a href="#或" class="headerlink" title="或"></a>或</h4><p>有时候，我们可能会需要在匹配时用到或者的关系，利用之前的’[]’字符类（字符集合）可能只能匹配单个字符的或者关系，比如匹配a或b，你可以这样写：’[ab]’，但是如果你需要匹配的是一整个单词的或者关系呢，这个时候’[]’就不好使了。这时候，我们用’|’可以达到或的效果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//匹配单词Byron或者Casper</span><br><span class="line">var reg = /Byron|Casper/g;</span><br><span class="line">var text = &apos;ByronCasper&apos;</span><br><span class="line">var result = text.replace(reg,&apos;X&apos;);</span><br><span class="line">console.log(result);//XX</span><br><span class="line"></span><br><span class="line">//匹配Byr+on或Ca+sper</span><br><span class="line">var reg = /Byr(on|Ca)sper/g;</span><br><span class="line">var text = &apos;ByronsperByrCasper&apos;</span><br><span class="line">var result1 = text.replace(reg,&apos;X&apos;);</span><br><span class="line">console.log(result1);//XX</span><br></pre></td></tr></table></figure><p></p><h4 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h4><blockquote><p>思考：把日期’2015-12-25’替换成’12/25/2015’</p></blockquote><p>这时候，正则的反向引用就可以取到作用了。表达式在匹配时，表达式引擎会将小括号 “( )” 包含的表达式所匹配到的字符串记录（分组捕获）下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。</p><p>在js中正则匹配成功的字符串可以用$1表示第一次匹配成功，$3表示第三次匹配成功的字符，以此类推至$99）。于是，上面的例子就可以这样写了：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'2015-12-25'</span></span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'$2/$3/$1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//12/25/2015</span></span><br></pre></td></tr></table></figure><p></p><h4 id="忽略分组"><a href="#忽略分组" class="headerlink" title="忽略分组"></a>忽略分组</h4><p>在上面的反向引用中，我们默认是根据’()’全部捕获记录为$1~$99的，倘若我们想忽略某个捕获要怎么办呢？</p><p>不希望捕获某些分组，只需要在分组内加上’?:’就可以了。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(?:Byron)(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">'Byron2016-12-05'</span></span><br><span class="line"><span class="keyword">var</span> result = text.replace(reg,<span class="string">'$2/$3/$1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result);<span class="comment">//12/05/2016</span></span><br></pre></td></tr></table></figure><p></p><h3 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h3><hr><blockquote><p>思考： var reg1 = /\w/; var reg2 = /\w/g;那么reg1.test(‘a’)和 reg2.test(‘ab’)的结果分别是什么？</p></blockquote><p>我们在用正则表达式相关的方法时，经常会用到正则表达式相关的一些对象属性，下面我们总结一下正则表达式相关的对象属性：</p><ul><li>golbal: 是否全文搜索，默认false</li><li>ignore case: 是否大小写敏感，默认false</li><li>multiline: 多行搜索，默认false</li><li>lastIndex: 是当前表达式匹配内容的最后一个字符的下一个位置</li><li>source: 正则表达式的文本字符串</li></ul><p>其中前面三个我们在上文中已经提到过了，source的话，我们一起结合起来看看代码：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/\w/</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/\w/gim</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg1.global);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg1.ignoreCase);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(reg1.multiline);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg2.global);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.ignoreCase);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.multiline);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg1.source);<span class="comment">//\w</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.source);<span class="comment">//\w</span></span><br></pre></td></tr></table></figure><p></p><h3 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h3><hr><p>支持正则表达式的 String 对象的方法有：</p><ul><li>search： 检索与正则表达式相匹配的值</li><li>match： 找到一个或多个正则表达式的匹配。</li><li>replace： 替换与正则表达式匹配的子串。</li><li>split： 把字符串分割为字符串数组。<h4 id="search"><a href="#search" class="headerlink" title="search"></a>search</h4>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式匹配的子字符串<br>语法为stringObject.search(regexp),结果返回 stringObject 中第一个与 regexp 相匹配的子串的起始位置index，如果没有找到任何匹配的子串，则返回 -1。需要注意的是，search() 方法不执行全局匹配，它将忽略修饰符’g’,并且总是从字符串的开始进行检索。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a1b2c3d4'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">'1'</span>)); <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="string">'10'</span>)); <span class="comment">//-1</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/b2/</span>)); <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/\w\d/g</span>)); <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(<span class="regexp">/\w\d/g</span>)); <span class="comment">//0 忽略'g',执行多次未返回不同结果</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="match"><a href="#match" class="headerlink" title="match"></a>match</h4><p>match() 方法将检索字符串，以找到一个或多个与 RegExp 匹配的文本，在 RegExp 是否有修饰符’g’影响很大。它返回指定的值，而不是字符串的位置。</p><p>语法为stringObject.match(searchvalue)或stringObject.match(regexp)，结果返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p><h4 id="1-非全局调用"><a href="#1-非全局调用" class="headerlink" title="1.非全局调用"></a>1.非全局调用</h4><ul><li>如果 regexp 没有标志 g ，那么 match() 方法就只能在字符串中执行匹配一次</li><li>如果没有找到任何匹配文本，返回 null</li><li>否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息：</li><li>数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/\d(\w)\d/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'1a2b3c4d5e'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.match(reg3);</span><br><span class="line"><span class="built_in">console</span>.log(arr);<span class="comment">//  [1a2, a]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="全局调用"><a href="#全局调用" class="headerlink" title="全局调用"></a>全局调用</h4><p>全局调用就和 exec() 不同了：</p><ul><li>如果 regexp 具有标志 g 则 match() 方法将执行全局检索，找到字符串中所有匹配的子字符串</li><li>没有找到任何匹配的子字符串则返回 null</li><li>如果找到了一个或者多个匹配字串，则返回一个数组</li><li>数组元素中存放的是字符串中所有匹配的字串，而且也没有index属性和input属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg4 = <span class="regexp">/\d(\w)(\w)\d/g</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'$1az2bb3cy4dd5ee'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.match(reg4)</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ["1az2", "3cy4"]</span></span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split"></a>split</h3><p>我们经常用它把字符串分割为数组。但是你可能不知道，我们在一些复杂情况下我们可以使用正则表达式解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a,b,c,d'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.split(<span class="string">','</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//['a','b','c','d']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--那如果是这样的字符串呢--&gt;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'a1b2c3d'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = str.split(<span class="regexp">/\d/</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">//['a','b','c','d']</span></span><br></pre></td></tr></table></figure><blockquote><p>其实，我们在用 split() 分割字符’,’的时候，split() 方法也是把’,’ 隐士转换成正则’/,/‘的, search() 方法和 replace() 方法也是一样的。</p></blockquote><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。<br>语法为stringObject.replace(regexp/substr,replacement),结果返回一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。</p></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://itlinnnn.github.io/linhui.github.io/linhui.github.io/js中this的指向/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="林晖"><meta itemprop="description" content=""><meta itemprop="image" content="/linhui.github.io/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="林晖的个人博客"></span><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/linhui.github.io/js中this的指向/" itemprop="url">js中this的指向</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-21T17:38:00+08:00">2018-07-21</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="为什么要使用this-解决的问题？"><a href="#为什么要使用this-解决的问题？" class="headerlink" title="为什么要使用this? 解决的问题？"></a>为什么要使用this? 解决的问题？</h2><blockquote><p>可以先通过一个例子了解下<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="keyword">this</span>.name</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello I am --"</span> + name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">  name: <span class="string">'a'</span>,</span><br><span class="line">  speak: speak</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">  name: <span class="string">'b'</span>,</span><br><span class="line">  speak: speak</span><br><span class="line">&#125;</span><br><span class="line">me.speak()  <span class="comment">//Hello I am -- a</span></span><br><span class="line">you.speak()  <span class="comment">//Hello I am -- b</span></span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>this可以在同一个执行环境中使用不同的上下文对象。它其实提供了一种更加优雅的方式来隐式“传递”一个对象引用，因此可以使API设计的更加简洁且易于复用。</p></blockquote><h4 id="定义：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象"><a href="#定义：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象" class="headerlink" title="定义：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象"></a>定义：this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</h4><p>其实关于this的指向问题可以从函数的执行调用过程中理解，当一个函数被调用时，会创建一个活动记录(执行上下文)。这个记录会包含函数在哪里被调用、函数的调用方法、传入的参数等信息，this也是这里的一个属性。当函数被某个对象调用时可以理解为在函数调用的那一刻它被调用对象拥有。所以this指向调用其的对象。</p><blockquote><p>对于this的指向问题，一般都是根据以上的解释去理解，虽然在一般的情况下这样的理解是不会有问题的，但是当在某些场景下这样的解释并不是很准确，所以会让人感觉一直琢磨不透的感觉。今天可以就不同情况展开讨论下this指向的问题。看看下面的打印结果会是什么</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="comment">// 例子二</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  b: <span class="number">20</span>,</span><br><span class="line">  fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.fn();</span><br></pre></td></tr></table></figure><blockquote><p>按照上面的定义this最终指向的是调用它的对象，这里的函数test实际是被Window对象所点出来的。所以例子1中的this指向的是windows。在例子2中函数的执行是通过o.fn()调用的，所以this的指向的当然是对象o了。这两个例子可以验证上面的定义，但是还是不够准确的。<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子三</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  b: <span class="number">20</span>,</span><br><span class="line">  fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.b); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.o.fn();</span><br></pre></td></tr></table></figure><p></p></blockquote><p>此时打印的应该是什么呢？这段代码和上面的那段代码几乎是一样的，但是这里的this为什么不是指向window，如果按照上面的理论，最终this指向的是调用它的对象，在此处就显得不是很准确了。所以关于函数中this的指向其实是可以分为三种情况的</p><ul><li>如果一个函数中有this，但是它没有被上一级的对象所调用，那么this指向的就是window</li><li>如果一个函数中有this，这个函数有被上一级的对象所调用，那么this指向的就是上一级的对象。</li><li>如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象，这就可以解释例子三中的this不是指向window了<h4 id="那么以下的打印结果又应该是什么？"><a href="#那么以下的打印结果又应该是什么？" class="headerlink" title="那么以下的打印结果又应该是什么？"></a>那么以下的打印结果又应该是什么？</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子4</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a:<span class="number">10</span>,</span><br><span class="line">  b:&#123;</span><br><span class="line">    a:<span class="number">12</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.a); </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> j = o.b.fn;</span><br><span class="line">j();</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>此处的this指向的是window,其实这里只需要理解清楚一句话”this永远指向的是最后调用它的对象”,也就是看它执行的时候是谁调用的，例子4中虽然函数fn是被对象b所引用，但是在将fn赋值给变量j的时候并没有执行所以最终指向的是window，这和例子3是不一样的，例子3是直接执行了fn。所以说，那例子5中的打印结果又应该是什么呢？<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; </span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数别名!</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"xxxxx"</span></span><br><span class="line">bar();</span><br></pre></td></tr></table></figure><p></p></blockquote><h3 id="不同情况下this的使用"><a href="#不同情况下this的使用" class="headerlink" title="不同情况下this的使用"></a>不同情况下this的使用</h3><p>1.构造函数版this<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.user = <span class="string">"lh"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Fn();</span><br><span class="line"><span class="built_in">console</span>.log(a.user);</span><br></pre></td></tr></table></figure><p></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用new指向window</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="string">'inwe'</span>)</span><br><span class="line"><span class="comment">//使用new</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//people</span></span><br><span class="line">      self = <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> people = <span class="keyword">new</span> Person(<span class="string">'iwen'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(self === people) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><blockquote><p>这里之所以对象a可以点出函数Fn里面的user是因为new关键字可以改变this的指向，将这个this指向对象a，我们这里用变量a创建了一个Fn的实例（相当于复制了一份Fn到对象a里面），此时仅仅只是创建，并没有执行，而调用这个函数Fn的是对象a，那么this指向的自然是对象a，那么为什么对象Fn中会有user，因为已经复制了一份Fn函数到对象a中，用了new关键字就等同于复制了一份。</p></blockquote><p>！当this遇上return时<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子7</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">this</span>.user = <span class="string">'lh'</span>;  </span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子8</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">this</span>.user = <span class="string">'lh'</span>;  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line">  <span class="built_in">console</span>.log(a.user)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子9</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">this</span>.user = <span class="string">'lh'</span>;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> fn;  </span><br><span class="line"><span class="built_in">console</span>.log(a.user);</span><br></pre></td></tr></table></figure><p></p><blockquote><p>由上可知，如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</p></blockquote><p>2.箭头函数中的this<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x=<span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line"> x:<span class="number">22</span>,</span><br><span class="line"> say:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.say();</span><br></pre></td></tr></table></figure><p></p><blockquote><p>箭头函数不是通过function关键字定义的，也就不遵循以上的this规则，而是“继承”外层作用域中的this指向。箭头函数中的this是在定义函数的时候绑定，而不是在执行函数的时候绑定。所谓的定义时候绑定，就是this是继承自父执行上下文！！中的this，比如这里的箭头函数中的this.x，箭头函数本身与say平级以key:value的形式，也就是箭头函数本身所在的对象为obj，而obj的父执行上下文就是window，因此这里的this.x实际上表示的是window.x，因此输出的是11。</p></blockquote><h3 id="改变this指向的几种方法（apply，call-bind）"><a href="#改变this指向的几种方法（apply，call-bind）" class="headerlink" title="改变this指向的几种方法（apply，call, bind）"></a>改变this指向的几种方法（apply，call, bind）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  user:<span class="string">"lh"</span>,</span><br><span class="line">  fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.user);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure><ul><li>此时要改变this的指向，可以通过call方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  user:<span class="string">"lh"</span>,</span><br><span class="line">  fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.user);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.call(a);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>通过在call方法，给第一个参数添加要把b添加到哪个环境中，也就是说，this就会指向那个对象。<br>call方法除了第一个参数以外还可以添加多个参数，如下</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  user:<span class="string">"lh"</span>,</span><br><span class="line">  fn:<span class="function"><span class="keyword">function</span>(<span class="params">p1, p2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.user)</span><br><span class="line">    <span class="built_in">console</span>.log(p1+p2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.call(a, <span class="number">1</span>, <span class="number">3</span>）</span><br></pre></td></tr></table></figure><ul><li>使用apply()方法，改变this指向的效果和call相似，在于他们传递的参数格式不同，第二个参数必须是一个数组，如下:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  user:<span class="string">"lh"</span>,</span><br><span class="line">  fn:<span class="function"><span class="keyword">function</span>(<span class="params">p1, p2</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.user)</span><br><span class="line">    <span class="built_in">console</span>.log(p1+p2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.apply(a, [<span class="number">1</span>, <span class="number">3</span>]）</span><br></pre></td></tr></table></figure></li></ul><h3 id="当call和apply的第一个参数写的是null，那么this指向的是window对象"><a href="#当call和apply的第一个参数写的是null，那么this指向的是window对象" class="headerlink" title="!当call和apply的第一个参数写的是null，那么this指向的是window对象"></a>!当call和apply的第一个参数写的是null，那么this指向的是window对象</h3><ul><li>bind()方法<blockquote><p>bind()方法也可用来改变this的指向，但是和call,apply方法在用法上有区别,如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    user:<span class="string">"lh"</span>,</span><br><span class="line">    fn:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = a.fn;</span><br><span class="line">b.bind(a);</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>此时发现并不打印任何的结果，这是因为bind方法返回的是一个修改过后的函数,此时执行conole.log(b.bind(a))会得到的结果是：<br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ƒ () &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>call和apply都是改变上下文中的this并立即执行这个函数，bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加，这是它们的区别，根据自己的实际情况来选择使用。并且也是可以像call和apply一样传递参数</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/linhui.github.io/page/2/">2</a><a class="extend next" rel="next" href="/linhui.github.io/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">林晖</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/linhui.github.io/archives/"><span class="site-state-item-count">18</span> <span class="site-state-item-name">posts</span></a></div></nav><div class="feed-link motion-element"><a href="/linhui.github.io/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">林晖</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/linhui.github.io/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/linhui.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/linhui.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/linhui.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/linhui.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/linhui.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/linhui.github.io/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/linhui.github.io/js/src/bootstrap.js?v=5.1.4"></script></body></html>